{-
   Argo

   No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

   OpenAPI spec version: 2.0
   Argo API version: v2.1.0
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : Argo.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Argo.Model where

import Argo.Core
import Argo.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** V1alpha1Arguments
-- | V1alpha1Arguments
-- Arguments to a template
data V1alpha1Arguments = V1alpha1Arguments
  { v1alpha1ArgumentsArtifacts :: !(Maybe [V1alpha1Artifact]) -- ^ "artifacts" - Artifacts is the list of artifacts to pass to the template or workflow
  , v1alpha1ArgumentsParameters :: !(Maybe [V1alpha1Parameter]) -- ^ "parameters" - Parameters is the list of parameters to pass to the template or workflow
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Arguments
instance A.FromJSON V1alpha1Arguments where
  parseJSON = A.withObject "V1alpha1Arguments" $ \o ->
    V1alpha1Arguments
      <$> (o .:? "artifacts")
      <*> (o .:? "parameters")

-- | ToJSON V1alpha1Arguments
instance A.ToJSON V1alpha1Arguments where
  toJSON V1alpha1Arguments {..} =
   _omitNulls
      [ "artifacts" .= v1alpha1ArgumentsArtifacts
      , "parameters" .= v1alpha1ArgumentsParameters
      ]


-- | Construct a value of type 'V1alpha1Arguments' (by applying it's required fields, if any)
mkV1alpha1Arguments
  :: V1alpha1Arguments
mkV1alpha1Arguments =
  V1alpha1Arguments
  { v1alpha1ArgumentsArtifacts = Nothing
  , v1alpha1ArgumentsParameters = Nothing
  }

-- ** V1alpha1Artifact
-- | V1alpha1Artifact
-- Artifact indicates an artifact to place at a specified path
data V1alpha1Artifact = V1alpha1Artifact
  { v1alpha1ArtifactArtifactory :: !(Maybe V1alpha1ArtifactoryArtifact) -- ^ "artifactory" - Artifactory contains artifactory artifact location details
  , v1alpha1ArtifactFrom :: !(Maybe Text) -- ^ "from" - From allows an artifact to reference an artifact from a previous step
  , v1alpha1ArtifactGit :: !(Maybe V1alpha1GitArtifact) -- ^ "git" - Git contains git artifact location details
  , v1alpha1ArtifactGlobalName :: !(Maybe Text) -- ^ "globalName" - GlobalName exports an output artifact to the global scope, making it available as &#39;{{workflow.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
  , v1alpha1ArtifactHttp :: !(Maybe V1alpha1HTTPArtifact) -- ^ "http" - HTTP contains HTTP artifact location details
  , v1alpha1ArtifactMode :: !(Maybe Int) -- ^ "mode" - mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts.
  , v1alpha1ArtifactName :: !(Text) -- ^ /Required/ "name" - name of the artifact. must be unique within a template&#39;s inputs/outputs.
  , v1alpha1ArtifactPath :: !(Maybe Text) -- ^ "path" - Path is the container path to the artifact
  , v1alpha1ArtifactRaw :: !(Maybe V1alpha1RawArtifact) -- ^ "raw" - Raw contains raw artifact location details
  , v1alpha1ArtifactS3 :: !(Maybe V1alpha1S3Artifact) -- ^ "s3" - S3 contains S3 artifact location details
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Artifact
instance A.FromJSON V1alpha1Artifact where
  parseJSON = A.withObject "V1alpha1Artifact" $ \o ->
    V1alpha1Artifact
      <$> (o .:? "artifactory")
      <*> (o .:? "from")
      <*> (o .:? "git")
      <*> (o .:? "globalName")
      <*> (o .:? "http")
      <*> (o .:? "mode")
      <*> (o .:  "name")
      <*> (o .:? "path")
      <*> (o .:? "raw")
      <*> (o .:? "s3")

-- | ToJSON V1alpha1Artifact
instance A.ToJSON V1alpha1Artifact where
  toJSON V1alpha1Artifact {..} =
   _omitNulls
      [ "artifactory" .= v1alpha1ArtifactArtifactory
      , "from" .= v1alpha1ArtifactFrom
      , "git" .= v1alpha1ArtifactGit
      , "globalName" .= v1alpha1ArtifactGlobalName
      , "http" .= v1alpha1ArtifactHttp
      , "mode" .= v1alpha1ArtifactMode
      , "name" .= v1alpha1ArtifactName
      , "path" .= v1alpha1ArtifactPath
      , "raw" .= v1alpha1ArtifactRaw
      , "s3" .= v1alpha1ArtifactS3
      ]


-- | Construct a value of type 'V1alpha1Artifact' (by applying it's required fields, if any)
mkV1alpha1Artifact
  :: Text -- ^ 'v1alpha1ArtifactName': name of the artifact. must be unique within a template's inputs/outputs.
  -> V1alpha1Artifact
mkV1alpha1Artifact v1alpha1ArtifactName =
  V1alpha1Artifact
  { v1alpha1ArtifactArtifactory = Nothing
  , v1alpha1ArtifactFrom = Nothing
  , v1alpha1ArtifactGit = Nothing
  , v1alpha1ArtifactGlobalName = Nothing
  , v1alpha1ArtifactHttp = Nothing
  , v1alpha1ArtifactMode = Nothing
  , v1alpha1ArtifactName
  , v1alpha1ArtifactPath = Nothing
  , v1alpha1ArtifactRaw = Nothing
  , v1alpha1ArtifactS3 = Nothing
  }

-- ** V1alpha1ArtifactLocation
-- | V1alpha1ArtifactLocation
-- ArtifactLocation describes a location for a single or multiple artifacts. It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname). It is also used to describe the location of multiple artifacts such as the archive location of a single workflow step, which the executor will use as a default location to store its files.
data V1alpha1ArtifactLocation = V1alpha1ArtifactLocation
  { v1alpha1ArtifactLocationArtifactory :: !(Maybe V1alpha1ArtifactoryArtifact) -- ^ "artifactory" - Artifactory contains artifactory artifact location details
  , v1alpha1ArtifactLocationGit :: !(Maybe V1alpha1GitArtifact) -- ^ "git" - Git contains git artifact location details
  , v1alpha1ArtifactLocationHttp :: !(Maybe V1alpha1HTTPArtifact) -- ^ "http" - HTTP contains HTTP artifact location details
  , v1alpha1ArtifactLocationRaw :: !(Maybe V1alpha1RawArtifact) -- ^ "raw" - Raw contains raw artifact location details
  , v1alpha1ArtifactLocationS3 :: !(Maybe V1alpha1S3Artifact) -- ^ "s3" - S3 contains S3 artifact location details
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1ArtifactLocation
instance A.FromJSON V1alpha1ArtifactLocation where
  parseJSON = A.withObject "V1alpha1ArtifactLocation" $ \o ->
    V1alpha1ArtifactLocation
      <$> (o .:? "artifactory")
      <*> (o .:? "git")
      <*> (o .:? "http")
      <*> (o .:? "raw")
      <*> (o .:? "s3")

-- | ToJSON V1alpha1ArtifactLocation
instance A.ToJSON V1alpha1ArtifactLocation where
  toJSON V1alpha1ArtifactLocation {..} =
   _omitNulls
      [ "artifactory" .= v1alpha1ArtifactLocationArtifactory
      , "git" .= v1alpha1ArtifactLocationGit
      , "http" .= v1alpha1ArtifactLocationHttp
      , "raw" .= v1alpha1ArtifactLocationRaw
      , "s3" .= v1alpha1ArtifactLocationS3
      ]


-- | Construct a value of type 'V1alpha1ArtifactLocation' (by applying it's required fields, if any)
mkV1alpha1ArtifactLocation
  :: V1alpha1ArtifactLocation
mkV1alpha1ArtifactLocation =
  V1alpha1ArtifactLocation
  { v1alpha1ArtifactLocationArtifactory = Nothing
  , v1alpha1ArtifactLocationGit = Nothing
  , v1alpha1ArtifactLocationHttp = Nothing
  , v1alpha1ArtifactLocationRaw = Nothing
  , v1alpha1ArtifactLocationS3 = Nothing
  }

-- ** V1alpha1ArtifactoryArtifact
-- | V1alpha1ArtifactoryArtifact
-- ArtifactoryArtifact is the location of an artifactory artifact
data V1alpha1ArtifactoryArtifact = V1alpha1ArtifactoryArtifact
  { v1alpha1ArtifactoryArtifactPasswordSecret :: !(Maybe V1SecretKeySelector) -- ^ "passwordSecret" - PasswordSecret is the secret selector to the repository password
  , v1alpha1ArtifactoryArtifactUrl :: !(Text) -- ^ /Required/ "url" - URL of the artifact
  , v1alpha1ArtifactoryArtifactUsernameSecret :: !(Maybe V1SecretKeySelector) -- ^ "usernameSecret" - UsernameSecret is the secret selector to the repository username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1ArtifactoryArtifact
instance A.FromJSON V1alpha1ArtifactoryArtifact where
  parseJSON = A.withObject "V1alpha1ArtifactoryArtifact" $ \o ->
    V1alpha1ArtifactoryArtifact
      <$> (o .:? "passwordSecret")
      <*> (o .:  "url")
      <*> (o .:? "usernameSecret")

-- | ToJSON V1alpha1ArtifactoryArtifact
instance A.ToJSON V1alpha1ArtifactoryArtifact where
  toJSON V1alpha1ArtifactoryArtifact {..} =
   _omitNulls
      [ "passwordSecret" .= v1alpha1ArtifactoryArtifactPasswordSecret
      , "url" .= v1alpha1ArtifactoryArtifactUrl
      , "usernameSecret" .= v1alpha1ArtifactoryArtifactUsernameSecret
      ]


-- | Construct a value of type 'V1alpha1ArtifactoryArtifact' (by applying it's required fields, if any)
mkV1alpha1ArtifactoryArtifact
  :: Text -- ^ 'v1alpha1ArtifactoryArtifactUrl': URL of the artifact
  -> V1alpha1ArtifactoryArtifact
mkV1alpha1ArtifactoryArtifact v1alpha1ArtifactoryArtifactUrl =
  V1alpha1ArtifactoryArtifact
  { v1alpha1ArtifactoryArtifactPasswordSecret = Nothing
  , v1alpha1ArtifactoryArtifactUrl
  , v1alpha1ArtifactoryArtifactUsernameSecret = Nothing
  }

-- ** V1alpha1ArtifactoryAuth
-- | V1alpha1ArtifactoryAuth
-- ArtifactoryAuth describes the secret selectors required for authenticating to artifactory
data V1alpha1ArtifactoryAuth = V1alpha1ArtifactoryAuth
  { v1alpha1ArtifactoryAuthPasswordSecret :: !(Maybe V1SecretKeySelector) -- ^ "passwordSecret" - PasswordSecret is the secret selector to the repository password
  , v1alpha1ArtifactoryAuthUsernameSecret :: !(Maybe V1SecretKeySelector) -- ^ "usernameSecret" - UsernameSecret is the secret selector to the repository username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1ArtifactoryAuth
instance A.FromJSON V1alpha1ArtifactoryAuth where
  parseJSON = A.withObject "V1alpha1ArtifactoryAuth" $ \o ->
    V1alpha1ArtifactoryAuth
      <$> (o .:? "passwordSecret")
      <*> (o .:? "usernameSecret")

-- | ToJSON V1alpha1ArtifactoryAuth
instance A.ToJSON V1alpha1ArtifactoryAuth where
  toJSON V1alpha1ArtifactoryAuth {..} =
   _omitNulls
      [ "passwordSecret" .= v1alpha1ArtifactoryAuthPasswordSecret
      , "usernameSecret" .= v1alpha1ArtifactoryAuthUsernameSecret
      ]


-- | Construct a value of type 'V1alpha1ArtifactoryAuth' (by applying it's required fields, if any)
mkV1alpha1ArtifactoryAuth
  :: V1alpha1ArtifactoryAuth
mkV1alpha1ArtifactoryAuth =
  V1alpha1ArtifactoryAuth
  { v1alpha1ArtifactoryAuthPasswordSecret = Nothing
  , v1alpha1ArtifactoryAuthUsernameSecret = Nothing
  }

-- ** V1alpha1DAGTask
-- | V1alpha1DAGTask
-- DAGTask represents a node in the graph during DAG execution
data V1alpha1DAGTask = V1alpha1DAGTask
  { v1alpha1DAGTaskArguments :: !(Maybe V1alpha1Arguments) -- ^ "arguments" - Arguments are the parameter and artifact arguments to the template
  , v1alpha1DAGTaskDependencies :: !(Maybe [Text]) -- ^ "dependencies" - Dependencies are name of other targets which this depends on
  , v1alpha1DAGTaskName :: !(Text) -- ^ /Required/ "name" - Name is the name of the target
  , v1alpha1DAGTaskTemplate :: !(Text) -- ^ /Required/ "template" - Name of template to execute
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1DAGTask
instance A.FromJSON V1alpha1DAGTask where
  parseJSON = A.withObject "V1alpha1DAGTask" $ \o ->
    V1alpha1DAGTask
      <$> (o .:? "arguments")
      <*> (o .:? "dependencies")
      <*> (o .:  "name")
      <*> (o .:  "template")

-- | ToJSON V1alpha1DAGTask
instance A.ToJSON V1alpha1DAGTask where
  toJSON V1alpha1DAGTask {..} =
   _omitNulls
      [ "arguments" .= v1alpha1DAGTaskArguments
      , "dependencies" .= v1alpha1DAGTaskDependencies
      , "name" .= v1alpha1DAGTaskName
      , "template" .= v1alpha1DAGTaskTemplate
      ]


-- | Construct a value of type 'V1alpha1DAGTask' (by applying it's required fields, if any)
mkV1alpha1DAGTask
  :: Text -- ^ 'v1alpha1DAGTaskName': Name is the name of the target
  -> Text -- ^ 'v1alpha1DAGTaskTemplate': Name of template to execute
  -> V1alpha1DAGTask
mkV1alpha1DAGTask v1alpha1DAGTaskName v1alpha1DAGTaskTemplate =
  V1alpha1DAGTask
  { v1alpha1DAGTaskArguments = Nothing
  , v1alpha1DAGTaskDependencies = Nothing
  , v1alpha1DAGTaskName
  , v1alpha1DAGTaskTemplate
  }

-- ** V1alpha1DAGTemplate
-- | V1alpha1DAGTemplate
-- DAGTemplate is a template subtype for directed acyclic graph templates
data V1alpha1DAGTemplate = V1alpha1DAGTemplate
  { v1alpha1DAGTemplateTarget :: !(Maybe Text) -- ^ "target" - Target are one or more names of targets to execute in a DAG
  , v1alpha1DAGTemplateTasks :: !([V1alpha1DAGTask]) -- ^ /Required/ "tasks" - Tasks are a list of DAG tasks
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1DAGTemplate
instance A.FromJSON V1alpha1DAGTemplate where
  parseJSON = A.withObject "V1alpha1DAGTemplate" $ \o ->
    V1alpha1DAGTemplate
      <$> (o .:? "target")
      <*> (o .:  "tasks")

-- | ToJSON V1alpha1DAGTemplate
instance A.ToJSON V1alpha1DAGTemplate where
  toJSON V1alpha1DAGTemplate {..} =
   _omitNulls
      [ "target" .= v1alpha1DAGTemplateTarget
      , "tasks" .= v1alpha1DAGTemplateTasks
      ]


-- | Construct a value of type 'V1alpha1DAGTemplate' (by applying it's required fields, if any)
mkV1alpha1DAGTemplate
  :: [V1alpha1DAGTask] -- ^ 'v1alpha1DAGTemplateTasks': Tasks are a list of DAG tasks
  -> V1alpha1DAGTemplate
mkV1alpha1DAGTemplate v1alpha1DAGTemplateTasks =
  V1alpha1DAGTemplate
  { v1alpha1DAGTemplateTarget = Nothing
  , v1alpha1DAGTemplateTasks
  }

-- ** V1alpha1GitArtifact
-- | V1alpha1GitArtifact
-- GitArtifact is the location of an git artifact
data V1alpha1GitArtifact = V1alpha1GitArtifact
  { v1alpha1GitArtifactPasswordSecret :: !(Maybe V1SecretKeySelector) -- ^ "passwordSecret" - PasswordSecret is the secret selector to the repository password
  , v1alpha1GitArtifactRepo :: !(Text) -- ^ /Required/ "repo" - Repo is the git repository
  , v1alpha1GitArtifactRevision :: !(Maybe Text) -- ^ "revision" - Revision is the git commit, tag, branch to checkout
  , v1alpha1GitArtifactUsernameSecret :: !(Maybe V1SecretKeySelector) -- ^ "usernameSecret" - UsernameSecret is the secret selector to the repository username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1GitArtifact
instance A.FromJSON V1alpha1GitArtifact where
  parseJSON = A.withObject "V1alpha1GitArtifact" $ \o ->
    V1alpha1GitArtifact
      <$> (o .:? "passwordSecret")
      <*> (o .:  "repo")
      <*> (o .:? "revision")
      <*> (o .:? "usernameSecret")

-- | ToJSON V1alpha1GitArtifact
instance A.ToJSON V1alpha1GitArtifact where
  toJSON V1alpha1GitArtifact {..} =
   _omitNulls
      [ "passwordSecret" .= v1alpha1GitArtifactPasswordSecret
      , "repo" .= v1alpha1GitArtifactRepo
      , "revision" .= v1alpha1GitArtifactRevision
      , "usernameSecret" .= v1alpha1GitArtifactUsernameSecret
      ]


-- | Construct a value of type 'V1alpha1GitArtifact' (by applying it's required fields, if any)
mkV1alpha1GitArtifact
  :: Text -- ^ 'v1alpha1GitArtifactRepo': Repo is the git repository
  -> V1alpha1GitArtifact
mkV1alpha1GitArtifact v1alpha1GitArtifactRepo =
  V1alpha1GitArtifact
  { v1alpha1GitArtifactPasswordSecret = Nothing
  , v1alpha1GitArtifactRepo
  , v1alpha1GitArtifactRevision = Nothing
  , v1alpha1GitArtifactUsernameSecret = Nothing
  }

-- ** V1alpha1HTTPArtifact
-- | V1alpha1HTTPArtifact
-- HTTPArtifact allows an file served on HTTP to be placed as an input artifact in a container
data V1alpha1HTTPArtifact = V1alpha1HTTPArtifact
  { v1alpha1HTTPArtifactUrl :: !(Text) -- ^ /Required/ "url" - URL of the artifact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1HTTPArtifact
instance A.FromJSON V1alpha1HTTPArtifact where
  parseJSON = A.withObject "V1alpha1HTTPArtifact" $ \o ->
    V1alpha1HTTPArtifact
      <$> (o .:  "url")

-- | ToJSON V1alpha1HTTPArtifact
instance A.ToJSON V1alpha1HTTPArtifact where
  toJSON V1alpha1HTTPArtifact {..} =
   _omitNulls
      [ "url" .= v1alpha1HTTPArtifactUrl
      ]


-- | Construct a value of type 'V1alpha1HTTPArtifact' (by applying it's required fields, if any)
mkV1alpha1HTTPArtifact
  :: Text -- ^ 'v1alpha1HTTPArtifactUrl': URL of the artifact
  -> V1alpha1HTTPArtifact
mkV1alpha1HTTPArtifact v1alpha1HTTPArtifactUrl =
  V1alpha1HTTPArtifact
  { v1alpha1HTTPArtifactUrl
  }

-- ** V1alpha1Inputs
-- | V1alpha1Inputs
-- Inputs are the mechanism for passing parameters, artifacts, volumes from one template to another
data V1alpha1Inputs = V1alpha1Inputs
  { v1alpha1InputsArtifacts :: !(Maybe [V1alpha1Artifact]) -- ^ "artifacts" - Artifact are a list of artifacts passed as inputs
  , v1alpha1InputsParameters :: !(Maybe [V1alpha1Parameter]) -- ^ "parameters" - Parameters are a list of parameters passed as inputs
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Inputs
instance A.FromJSON V1alpha1Inputs where
  parseJSON = A.withObject "V1alpha1Inputs" $ \o ->
    V1alpha1Inputs
      <$> (o .:? "artifacts")
      <*> (o .:? "parameters")

-- | ToJSON V1alpha1Inputs
instance A.ToJSON V1alpha1Inputs where
  toJSON V1alpha1Inputs {..} =
   _omitNulls
      [ "artifacts" .= v1alpha1InputsArtifacts
      , "parameters" .= v1alpha1InputsParameters
      ]


-- | Construct a value of type 'V1alpha1Inputs' (by applying it's required fields, if any)
mkV1alpha1Inputs
  :: V1alpha1Inputs
mkV1alpha1Inputs =
  V1alpha1Inputs
  { v1alpha1InputsArtifacts = Nothing
  , v1alpha1InputsParameters = Nothing
  }

-- ** V1alpha1Item
-- | V1alpha1Item
newtype V1alpha1Item = V1alpha1Item
  { unV1alpha1Item :: Text
  } deriving (P.Eq, P.Show, P.Typeable, A.ToJSON, A.FromJSON, WH.ToHttpApiData, WH.FromHttpApiData)


-- ** V1alpha1Metadata
-- | V1alpha1Metadata
-- Pod metdata
data V1alpha1Metadata = V1alpha1Metadata
  { v1alpha1MetadataAnnotations :: !(Maybe (Map.Map String Text)) -- ^ "annotations"
  , v1alpha1MetadataLabels :: !(Maybe (Map.Map String Text)) -- ^ "labels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Metadata
instance A.FromJSON V1alpha1Metadata where
  parseJSON = A.withObject "V1alpha1Metadata" $ \o ->
    V1alpha1Metadata
      <$> (o .:? "annotations")
      <*> (o .:? "labels")

-- | ToJSON V1alpha1Metadata
instance A.ToJSON V1alpha1Metadata where
  toJSON V1alpha1Metadata {..} =
   _omitNulls
      [ "annotations" .= v1alpha1MetadataAnnotations
      , "labels" .= v1alpha1MetadataLabels
      ]


-- | Construct a value of type 'V1alpha1Metadata' (by applying it's required fields, if any)
mkV1alpha1Metadata
  :: V1alpha1Metadata
mkV1alpha1Metadata =
  V1alpha1Metadata
  { v1alpha1MetadataAnnotations = Nothing
  , v1alpha1MetadataLabels = Nothing
  }

-- ** V1alpha1Outputs
-- | V1alpha1Outputs
-- Outputs hold parameters, artifacts, and results from a step
data V1alpha1Outputs = V1alpha1Outputs
  { v1alpha1OutputsArtifacts :: !(Maybe [V1alpha1Artifact]) -- ^ "artifacts" - Artifacts holds the list of output artifacts produced by a step
  , v1alpha1OutputsParameters :: !(Maybe [V1alpha1Parameter]) -- ^ "parameters" - Parameters holds the list of output parameters produced by a step
  , v1alpha1OutputsResult :: !(Maybe Text) -- ^ "result" - Result holds the result (stdout) of a script template
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Outputs
instance A.FromJSON V1alpha1Outputs where
  parseJSON = A.withObject "V1alpha1Outputs" $ \o ->
    V1alpha1Outputs
      <$> (o .:? "artifacts")
      <*> (o .:? "parameters")
      <*> (o .:? "result")

-- | ToJSON V1alpha1Outputs
instance A.ToJSON V1alpha1Outputs where
  toJSON V1alpha1Outputs {..} =
   _omitNulls
      [ "artifacts" .= v1alpha1OutputsArtifacts
      , "parameters" .= v1alpha1OutputsParameters
      , "result" .= v1alpha1OutputsResult
      ]


-- | Construct a value of type 'V1alpha1Outputs' (by applying it's required fields, if any)
mkV1alpha1Outputs
  :: V1alpha1Outputs
mkV1alpha1Outputs =
  V1alpha1Outputs
  { v1alpha1OutputsArtifacts = Nothing
  , v1alpha1OutputsParameters = Nothing
  , v1alpha1OutputsResult = Nothing
  }

-- ** V1alpha1Parameter
-- | V1alpha1Parameter
-- Parameter indicate a passed string parameter to a service template with an optional default value
data V1alpha1Parameter = V1alpha1Parameter
  { v1alpha1ParameterDefault :: !(Maybe Text) -- ^ "default" - Default is the default value to use for an input parameter if a value was not supplied
  , v1alpha1ParameterGlobalName :: !(Maybe Text) -- ^ "globalName" - GlobalName exports an output parameter to the global scope, making it available as &#39;{{workflow.outputs.parameters.XXXX}} and in workflow.status.outputs.parameters
  , v1alpha1ParameterName :: !(Text) -- ^ /Required/ "name" - Name is the parameter name
  , v1alpha1ParameterValue :: !(Maybe Text) -- ^ "value" - Value is the literal value to use for the parameter. If specified in the context of an input parameter, the value takes precedence over any passed values
  , v1alpha1ParameterValueFrom :: !(Maybe V1alpha1ValueFrom) -- ^ "valueFrom" - ValueFrom is the source for the output parameter&#39;s value
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Parameter
instance A.FromJSON V1alpha1Parameter where
  parseJSON = A.withObject "V1alpha1Parameter" $ \o ->
    V1alpha1Parameter
      <$> (o .:? "default")
      <*> (o .:? "globalName")
      <*> (o .:  "name")
      <*> (o .:? "value")
      <*> (o .:? "valueFrom")

-- | ToJSON V1alpha1Parameter
instance A.ToJSON V1alpha1Parameter where
  toJSON V1alpha1Parameter {..} =
   _omitNulls
      [ "default" .= v1alpha1ParameterDefault
      , "globalName" .= v1alpha1ParameterGlobalName
      , "name" .= v1alpha1ParameterName
      , "value" .= v1alpha1ParameterValue
      , "valueFrom" .= v1alpha1ParameterValueFrom
      ]


-- | Construct a value of type 'V1alpha1Parameter' (by applying it's required fields, if any)
mkV1alpha1Parameter
  :: Text -- ^ 'v1alpha1ParameterName': Name is the parameter name
  -> V1alpha1Parameter
mkV1alpha1Parameter v1alpha1ParameterName =
  V1alpha1Parameter
  { v1alpha1ParameterDefault = Nothing
  , v1alpha1ParameterGlobalName = Nothing
  , v1alpha1ParameterName
  , v1alpha1ParameterValue = Nothing
  , v1alpha1ParameterValueFrom = Nothing
  }

-- ** V1alpha1RawArtifact
-- | V1alpha1RawArtifact
-- RawArtifact allows raw string content to be placed as an artifact in a container
data V1alpha1RawArtifact = V1alpha1RawArtifact
  { v1alpha1RawArtifactData :: !(Text) -- ^ /Required/ "data" - Data is the string contents of the artifact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1RawArtifact
instance A.FromJSON V1alpha1RawArtifact where
  parseJSON = A.withObject "V1alpha1RawArtifact" $ \o ->
    V1alpha1RawArtifact
      <$> (o .:  "data")

-- | ToJSON V1alpha1RawArtifact
instance A.ToJSON V1alpha1RawArtifact where
  toJSON V1alpha1RawArtifact {..} =
   _omitNulls
      [ "data" .= v1alpha1RawArtifactData
      ]


-- | Construct a value of type 'V1alpha1RawArtifact' (by applying it's required fields, if any)
mkV1alpha1RawArtifact
  :: Text -- ^ 'v1alpha1RawArtifactData': Data is the string contents of the artifact
  -> V1alpha1RawArtifact
mkV1alpha1RawArtifact v1alpha1RawArtifactData =
  V1alpha1RawArtifact
  { v1alpha1RawArtifactData
  }

-- ** V1alpha1ResourceTemplate
-- | V1alpha1ResourceTemplate
-- ResourceTemplate is a template subtype to manipulate kubernetes resources
data V1alpha1ResourceTemplate = V1alpha1ResourceTemplate
  { v1alpha1ResourceTemplateAction :: !(Text) -- ^ /Required/ "action" - Action is the action to perform to the resource. Must be one of: get, create, apply, delete, replace
  , v1alpha1ResourceTemplateFailureCondition :: !(Maybe Text) -- ^ "failureCondition" - FailureCondition is a label selector expression which describes the conditions of the k8s resource in which the step was considered failed
  , v1alpha1ResourceTemplateManifest :: !(Text) -- ^ /Required/ "manifest" - Manifest contains the kubernetes manifest
  , v1alpha1ResourceTemplateSuccessCondition :: !(Maybe Text) -- ^ "successCondition" - SuccessCondition is a label selector expression which describes the conditions of the k8s resource in which it is acceptable to proceed to the following step
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1ResourceTemplate
instance A.FromJSON V1alpha1ResourceTemplate where
  parseJSON = A.withObject "V1alpha1ResourceTemplate" $ \o ->
    V1alpha1ResourceTemplate
      <$> (o .:  "action")
      <*> (o .:? "failureCondition")
      <*> (o .:  "manifest")
      <*> (o .:? "successCondition")

-- | ToJSON V1alpha1ResourceTemplate
instance A.ToJSON V1alpha1ResourceTemplate where
  toJSON V1alpha1ResourceTemplate {..} =
   _omitNulls
      [ "action" .= v1alpha1ResourceTemplateAction
      , "failureCondition" .= v1alpha1ResourceTemplateFailureCondition
      , "manifest" .= v1alpha1ResourceTemplateManifest
      , "successCondition" .= v1alpha1ResourceTemplateSuccessCondition
      ]


-- | Construct a value of type 'V1alpha1ResourceTemplate' (by applying it's required fields, if any)
mkV1alpha1ResourceTemplate
  :: Text -- ^ 'v1alpha1ResourceTemplateAction': Action is the action to perform to the resource. Must be one of: get, create, apply, delete, replace
  -> Text -- ^ 'v1alpha1ResourceTemplateManifest': Manifest contains the kubernetes manifest
  -> V1alpha1ResourceTemplate
mkV1alpha1ResourceTemplate v1alpha1ResourceTemplateAction v1alpha1ResourceTemplateManifest =
  V1alpha1ResourceTemplate
  { v1alpha1ResourceTemplateAction
  , v1alpha1ResourceTemplateFailureCondition = Nothing
  , v1alpha1ResourceTemplateManifest
  , v1alpha1ResourceTemplateSuccessCondition = Nothing
  }

-- ** V1alpha1RetryStrategy
-- | V1alpha1RetryStrategy
-- RetryStrategy provides controls on how to retry a workflow step
data V1alpha1RetryStrategy = V1alpha1RetryStrategy
  { v1alpha1RetryStrategyLimit :: !(Maybe Int) -- ^ "limit" - Limit is the maximum number of attempts when retrying a container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1RetryStrategy
instance A.FromJSON V1alpha1RetryStrategy where
  parseJSON = A.withObject "V1alpha1RetryStrategy" $ \o ->
    V1alpha1RetryStrategy
      <$> (o .:? "limit")

-- | ToJSON V1alpha1RetryStrategy
instance A.ToJSON V1alpha1RetryStrategy where
  toJSON V1alpha1RetryStrategy {..} =
   _omitNulls
      [ "limit" .= v1alpha1RetryStrategyLimit
      ]


-- | Construct a value of type 'V1alpha1RetryStrategy' (by applying it's required fields, if any)
mkV1alpha1RetryStrategy
  :: V1alpha1RetryStrategy
mkV1alpha1RetryStrategy =
  V1alpha1RetryStrategy
  { v1alpha1RetryStrategyLimit = Nothing
  }

-- ** V1alpha1S3Artifact
-- | V1alpha1S3Artifact
-- S3Artifact is the location of an S3 artifact
data V1alpha1S3Artifact = V1alpha1S3Artifact
  { v1alpha1S3ArtifactAccessKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "accessKeySecret" - AccessKeySecret is the secret selector to the bucket&#39;s access key
  , v1alpha1S3ArtifactBucket :: !(Text) -- ^ /Required/ "bucket" - Bucket is the name of the bucket
  , v1alpha1S3ArtifactEndpoint :: !(Text) -- ^ /Required/ "endpoint" - Endpoint is the hostname of the bucket endpoint
  , v1alpha1S3ArtifactInsecure :: !(Maybe Bool) -- ^ "insecure" - Insecure will connect to the service with TLS
  , v1alpha1S3ArtifactKey :: !(Text) -- ^ /Required/ "key" - Key is the key in the bucket where the artifact resides
  , v1alpha1S3ArtifactRegion :: !(Maybe Text) -- ^ "region" - Region contains the optional bucket region
  , v1alpha1S3ArtifactSecretKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "secretKeySecret" - SecretKeySecret is the secret selector to the bucket&#39;s secret key
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1S3Artifact
instance A.FromJSON V1alpha1S3Artifact where
  parseJSON = A.withObject "V1alpha1S3Artifact" $ \o ->
    V1alpha1S3Artifact
      <$> (o .:  "accessKeySecret")
      <*> (o .:  "bucket")
      <*> (o .:  "endpoint")
      <*> (o .:? "insecure")
      <*> (o .:  "key")
      <*> (o .:? "region")
      <*> (o .:  "secretKeySecret")

-- | ToJSON V1alpha1S3Artifact
instance A.ToJSON V1alpha1S3Artifact where
  toJSON V1alpha1S3Artifact {..} =
   _omitNulls
      [ "accessKeySecret" .= v1alpha1S3ArtifactAccessKeySecret
      , "bucket" .= v1alpha1S3ArtifactBucket
      , "endpoint" .= v1alpha1S3ArtifactEndpoint
      , "insecure" .= v1alpha1S3ArtifactInsecure
      , "key" .= v1alpha1S3ArtifactKey
      , "region" .= v1alpha1S3ArtifactRegion
      , "secretKeySecret" .= v1alpha1S3ArtifactSecretKeySecret
      ]


-- | Construct a value of type 'V1alpha1S3Artifact' (by applying it's required fields, if any)
mkV1alpha1S3Artifact
  :: V1SecretKeySelector -- ^ 'v1alpha1S3ArtifactAccessKeySecret': AccessKeySecret is the secret selector to the bucket's access key
  -> Text -- ^ 'v1alpha1S3ArtifactBucket': Bucket is the name of the bucket
  -> Text -- ^ 'v1alpha1S3ArtifactEndpoint': Endpoint is the hostname of the bucket endpoint
  -> Text -- ^ 'v1alpha1S3ArtifactKey': Key is the key in the bucket where the artifact resides
  -> V1SecretKeySelector -- ^ 'v1alpha1S3ArtifactSecretKeySecret': SecretKeySecret is the secret selector to the bucket's secret key
  -> V1alpha1S3Artifact
mkV1alpha1S3Artifact v1alpha1S3ArtifactAccessKeySecret v1alpha1S3ArtifactBucket v1alpha1S3ArtifactEndpoint v1alpha1S3ArtifactKey v1alpha1S3ArtifactSecretKeySecret =
  V1alpha1S3Artifact
  { v1alpha1S3ArtifactAccessKeySecret
  , v1alpha1S3ArtifactBucket
  , v1alpha1S3ArtifactEndpoint
  , v1alpha1S3ArtifactInsecure = Nothing
  , v1alpha1S3ArtifactKey
  , v1alpha1S3ArtifactRegion = Nothing
  , v1alpha1S3ArtifactSecretKeySecret
  }

-- ** V1alpha1S3Bucket
-- | V1alpha1S3Bucket
-- S3Bucket contains the access information required for interfacing with an S3 bucket
data V1alpha1S3Bucket = V1alpha1S3Bucket
  { v1alpha1S3BucketAccessKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "accessKeySecret" - AccessKeySecret is the secret selector to the bucket&#39;s access key
  , v1alpha1S3BucketBucket :: !(Text) -- ^ /Required/ "bucket" - Bucket is the name of the bucket
  , v1alpha1S3BucketEndpoint :: !(Text) -- ^ /Required/ "endpoint" - Endpoint is the hostname of the bucket endpoint
  , v1alpha1S3BucketInsecure :: !(Maybe Bool) -- ^ "insecure" - Insecure will connect to the service with TLS
  , v1alpha1S3BucketRegion :: !(Maybe Text) -- ^ "region" - Region contains the optional bucket region
  , v1alpha1S3BucketSecretKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "secretKeySecret" - SecretKeySecret is the secret selector to the bucket&#39;s secret key
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1S3Bucket
instance A.FromJSON V1alpha1S3Bucket where
  parseJSON = A.withObject "V1alpha1S3Bucket" $ \o ->
    V1alpha1S3Bucket
      <$> (o .:  "accessKeySecret")
      <*> (o .:  "bucket")
      <*> (o .:  "endpoint")
      <*> (o .:? "insecure")
      <*> (o .:? "region")
      <*> (o .:  "secretKeySecret")

-- | ToJSON V1alpha1S3Bucket
instance A.ToJSON V1alpha1S3Bucket where
  toJSON V1alpha1S3Bucket {..} =
   _omitNulls
      [ "accessKeySecret" .= v1alpha1S3BucketAccessKeySecret
      , "bucket" .= v1alpha1S3BucketBucket
      , "endpoint" .= v1alpha1S3BucketEndpoint
      , "insecure" .= v1alpha1S3BucketInsecure
      , "region" .= v1alpha1S3BucketRegion
      , "secretKeySecret" .= v1alpha1S3BucketSecretKeySecret
      ]


-- | Construct a value of type 'V1alpha1S3Bucket' (by applying it's required fields, if any)
mkV1alpha1S3Bucket
  :: V1SecretKeySelector -- ^ 'v1alpha1S3BucketAccessKeySecret': AccessKeySecret is the secret selector to the bucket's access key
  -> Text -- ^ 'v1alpha1S3BucketBucket': Bucket is the name of the bucket
  -> Text -- ^ 'v1alpha1S3BucketEndpoint': Endpoint is the hostname of the bucket endpoint
  -> V1SecretKeySelector -- ^ 'v1alpha1S3BucketSecretKeySecret': SecretKeySecret is the secret selector to the bucket's secret key
  -> V1alpha1S3Bucket
mkV1alpha1S3Bucket v1alpha1S3BucketAccessKeySecret v1alpha1S3BucketBucket v1alpha1S3BucketEndpoint v1alpha1S3BucketSecretKeySecret =
  V1alpha1S3Bucket
  { v1alpha1S3BucketAccessKeySecret
  , v1alpha1S3BucketBucket
  , v1alpha1S3BucketEndpoint
  , v1alpha1S3BucketInsecure = Nothing
  , v1alpha1S3BucketRegion = Nothing
  , v1alpha1S3BucketSecretKeySecret
  }

-- ** V1alpha1ScriptTemplate
-- | V1alpha1ScriptTemplate
-- ScriptTemplate is a template subtype to enable scripting through code steps
data V1alpha1ScriptTemplate = V1alpha1ScriptTemplate
  { v1alpha1ScriptTemplateArgs :: !(Maybe [Text]) -- ^ "args" - Arguments to the entrypoint. The docker image&#39;s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , v1alpha1ScriptTemplateCommand :: !(Maybe [Text]) -- ^ "command" - Entrypoint array. Not executed within a shell. The docker image&#39;s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , v1alpha1ScriptTemplateEnv :: !(Maybe [V1EnvVar]) -- ^ "env" - List of environment variables to set in the container. Cannot be updated.
  , v1alpha1ScriptTemplateEnvFrom :: !(Maybe [V1EnvFromSource]) -- ^ "envFrom" - List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
  , v1alpha1ScriptTemplateImage :: !(Maybe Text) -- ^ "image" - Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
  , v1alpha1ScriptTemplateImagePullPolicy :: !(Maybe Text) -- ^ "imagePullPolicy" - Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  , v1alpha1ScriptTemplateLifecycle :: !(Maybe V1Lifecycle) -- ^ "lifecycle" - Actions that the management system should take in response to container lifecycle events. Cannot be updated.
  , v1alpha1ScriptTemplateLivenessProbe :: !(Maybe V1Probe) -- ^ "livenessProbe" - Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , v1alpha1ScriptTemplateName :: !(Text) -- ^ /Required/ "name" - Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  , v1alpha1ScriptTemplatePorts :: !(Maybe [V1ContainerPort]) -- ^ "ports" - List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \&quot;0.0.0.0\&quot; address inside a container will be accessible from the network. Cannot be updated.
  , v1alpha1ScriptTemplateReadinessProbe :: !(Maybe V1Probe) -- ^ "readinessProbe" - Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , v1alpha1ScriptTemplateResources :: !(Maybe V1ResourceRequirements) -- ^ "resources" - Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  , v1alpha1ScriptTemplateSecurityContext :: !(Maybe V1SecurityContext) -- ^ "securityContext" - Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  , v1alpha1ScriptTemplateSource :: !(Text) -- ^ /Required/ "source" - Source contains the source code of the script to execute
  , v1alpha1ScriptTemplateStdin :: !(Maybe Bool) -- ^ "stdin" - Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
  , v1alpha1ScriptTemplateStdinOnce :: !(Maybe Bool) -- ^ "stdinOnce" - Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
  , v1alpha1ScriptTemplateTerminationMessagePath :: !(Maybe Text) -- ^ "terminationMessagePath" - Optional: Path at which the file to which the container&#39;s termination message will be written is mounted into the container&#39;s filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
  , v1alpha1ScriptTemplateTerminationMessagePolicy :: !(Maybe Text) -- ^ "terminationMessagePolicy" - Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
  , v1alpha1ScriptTemplateTty :: !(Maybe Bool) -- ^ "tty" - Whether this container should allocate a TTY for itself, also requires &#39;stdin&#39; to be true. Default is false.
  , v1alpha1ScriptTemplateVolumeDevices :: !(Maybe [V1VolumeDevice]) -- ^ "volumeDevices" - volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.
  , v1alpha1ScriptTemplateVolumeMounts :: !(Maybe [V1VolumeMount]) -- ^ "volumeMounts" - Pod volumes to mount into the container&#39;s filesystem. Cannot be updated.
  , v1alpha1ScriptTemplateWorkingDir :: !(Maybe Text) -- ^ "workingDir" - Container&#39;s working directory. If not specified, the container runtime&#39;s default will be used, which might be configured in the container image. Cannot be updated.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1ScriptTemplate
instance A.FromJSON V1alpha1ScriptTemplate where
  parseJSON = A.withObject "V1alpha1ScriptTemplate" $ \o ->
    V1alpha1ScriptTemplate
      <$> (o .:? "args")
      <*> (o .:? "command")
      <*> (o .:? "env")
      <*> (o .:? "envFrom")
      <*> (o .:? "image")
      <*> (o .:? "imagePullPolicy")
      <*> (o .:? "lifecycle")
      <*> (o .:? "livenessProbe")
      <*> (o .:  "name")
      <*> (o .:? "ports")
      <*> (o .:? "readinessProbe")
      <*> (o .:? "resources")
      <*> (o .:? "securityContext")
      <*> (o .:  "source")
      <*> (o .:? "stdin")
      <*> (o .:? "stdinOnce")
      <*> (o .:? "terminationMessagePath")
      <*> (o .:? "terminationMessagePolicy")
      <*> (o .:? "tty")
      <*> (o .:? "volumeDevices")
      <*> (o .:? "volumeMounts")
      <*> (o .:? "workingDir")

-- | ToJSON V1alpha1ScriptTemplate
instance A.ToJSON V1alpha1ScriptTemplate where
  toJSON V1alpha1ScriptTemplate {..} =
   _omitNulls
      [ "args" .= v1alpha1ScriptTemplateArgs
      , "command" .= v1alpha1ScriptTemplateCommand
      , "env" .= v1alpha1ScriptTemplateEnv
      , "envFrom" .= v1alpha1ScriptTemplateEnvFrom
      , "image" .= v1alpha1ScriptTemplateImage
      , "imagePullPolicy" .= v1alpha1ScriptTemplateImagePullPolicy
      , "lifecycle" .= v1alpha1ScriptTemplateLifecycle
      , "livenessProbe" .= v1alpha1ScriptTemplateLivenessProbe
      , "name" .= v1alpha1ScriptTemplateName
      , "ports" .= v1alpha1ScriptTemplatePorts
      , "readinessProbe" .= v1alpha1ScriptTemplateReadinessProbe
      , "resources" .= v1alpha1ScriptTemplateResources
      , "securityContext" .= v1alpha1ScriptTemplateSecurityContext
      , "source" .= v1alpha1ScriptTemplateSource
      , "stdin" .= v1alpha1ScriptTemplateStdin
      , "stdinOnce" .= v1alpha1ScriptTemplateStdinOnce
      , "terminationMessagePath" .= v1alpha1ScriptTemplateTerminationMessagePath
      , "terminationMessagePolicy" .= v1alpha1ScriptTemplateTerminationMessagePolicy
      , "tty" .= v1alpha1ScriptTemplateTty
      , "volumeDevices" .= v1alpha1ScriptTemplateVolumeDevices
      , "volumeMounts" .= v1alpha1ScriptTemplateVolumeMounts
      , "workingDir" .= v1alpha1ScriptTemplateWorkingDir
      ]


-- | Construct a value of type 'V1alpha1ScriptTemplate' (by applying it's required fields, if any)
mkV1alpha1ScriptTemplate
  :: Text -- ^ 'v1alpha1ScriptTemplateName': Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  -> Text -- ^ 'v1alpha1ScriptTemplateSource': Source contains the source code of the script to execute
  -> V1alpha1ScriptTemplate
mkV1alpha1ScriptTemplate v1alpha1ScriptTemplateName v1alpha1ScriptTemplateSource =
  V1alpha1ScriptTemplate
  { v1alpha1ScriptTemplateArgs = Nothing
  , v1alpha1ScriptTemplateCommand = Nothing
  , v1alpha1ScriptTemplateEnv = Nothing
  , v1alpha1ScriptTemplateEnvFrom = Nothing
  , v1alpha1ScriptTemplateImage = Nothing
  , v1alpha1ScriptTemplateImagePullPolicy = Nothing
  , v1alpha1ScriptTemplateLifecycle = Nothing
  , v1alpha1ScriptTemplateLivenessProbe = Nothing
  , v1alpha1ScriptTemplateName
  , v1alpha1ScriptTemplatePorts = Nothing
  , v1alpha1ScriptTemplateReadinessProbe = Nothing
  , v1alpha1ScriptTemplateResources = Nothing
  , v1alpha1ScriptTemplateSecurityContext = Nothing
  , v1alpha1ScriptTemplateSource
  , v1alpha1ScriptTemplateStdin = Nothing
  , v1alpha1ScriptTemplateStdinOnce = Nothing
  , v1alpha1ScriptTemplateTerminationMessagePath = Nothing
  , v1alpha1ScriptTemplateTerminationMessagePolicy = Nothing
  , v1alpha1ScriptTemplateTty = Nothing
  , v1alpha1ScriptTemplateVolumeDevices = Nothing
  , v1alpha1ScriptTemplateVolumeMounts = Nothing
  , v1alpha1ScriptTemplateWorkingDir = Nothing
  }

-- ** V1alpha1Sidecar
-- | V1alpha1Sidecar
-- Sidecar is a container which runs alongside the main container
data V1alpha1Sidecar = V1alpha1Sidecar
  { v1alpha1SidecarArgs :: !(Maybe [Text]) -- ^ "args" - Arguments to the entrypoint. The docker image&#39;s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , v1alpha1SidecarCommand :: !(Maybe [Text]) -- ^ "command" - Entrypoint array. Not executed within a shell. The docker image&#39;s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , v1alpha1SidecarEnv :: !(Maybe [V1EnvVar]) -- ^ "env" - List of environment variables to set in the container. Cannot be updated.
  , v1alpha1SidecarEnvFrom :: !(Maybe [V1EnvFromSource]) -- ^ "envFrom" - List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
  , v1alpha1SidecarImage :: !(Maybe Text) -- ^ "image" - Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
  , v1alpha1SidecarImagePullPolicy :: !(Maybe Text) -- ^ "imagePullPolicy" - Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  , v1alpha1SidecarLifecycle :: !(Maybe V1Lifecycle) -- ^ "lifecycle" - Actions that the management system should take in response to container lifecycle events. Cannot be updated.
  , v1alpha1SidecarLivenessProbe :: !(Maybe V1Probe) -- ^ "livenessProbe" - Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , v1alpha1SidecarMirrorVolumeMounts :: !(Maybe Bool) -- ^ "mirrorVolumeMounts" - MirrorVolumeMounts will mount the same volumes specified in the main container to the sidecar (including artifacts), at the same mountPaths. This enables dind daemon to partially see the same filesystem as the main container in order to use features such as docker volume binding
  , v1alpha1SidecarName :: !(Text) -- ^ /Required/ "name" - Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  , v1alpha1SidecarPorts :: !(Maybe [V1ContainerPort]) -- ^ "ports" - List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \&quot;0.0.0.0\&quot; address inside a container will be accessible from the network. Cannot be updated.
  , v1alpha1SidecarReadinessProbe :: !(Maybe V1Probe) -- ^ "readinessProbe" - Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , v1alpha1SidecarResources :: !(Maybe V1ResourceRequirements) -- ^ "resources" - Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  , v1alpha1SidecarSecurityContext :: !(Maybe V1SecurityContext) -- ^ "securityContext" - Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  , v1alpha1SidecarStdin :: !(Maybe Bool) -- ^ "stdin" - Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
  , v1alpha1SidecarStdinOnce :: !(Maybe Bool) -- ^ "stdinOnce" - Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
  , v1alpha1SidecarTerminationMessagePath :: !(Maybe Text) -- ^ "terminationMessagePath" - Optional: Path at which the file to which the container&#39;s termination message will be written is mounted into the container&#39;s filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
  , v1alpha1SidecarTerminationMessagePolicy :: !(Maybe Text) -- ^ "terminationMessagePolicy" - Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
  , v1alpha1SidecarTty :: !(Maybe Bool) -- ^ "tty" - Whether this container should allocate a TTY for itself, also requires &#39;stdin&#39; to be true. Default is false.
  , v1alpha1SidecarVolumeDevices :: !(Maybe [V1VolumeDevice]) -- ^ "volumeDevices" - volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.
  , v1alpha1SidecarVolumeMounts :: !(Maybe [V1VolumeMount]) -- ^ "volumeMounts" - Pod volumes to mount into the container&#39;s filesystem. Cannot be updated.
  , v1alpha1SidecarWorkingDir :: !(Maybe Text) -- ^ "workingDir" - Container&#39;s working directory. If not specified, the container runtime&#39;s default will be used, which might be configured in the container image. Cannot be updated.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Sidecar
instance A.FromJSON V1alpha1Sidecar where
  parseJSON = A.withObject "V1alpha1Sidecar" $ \o ->
    V1alpha1Sidecar
      <$> (o .:? "args")
      <*> (o .:? "command")
      <*> (o .:? "env")
      <*> (o .:? "envFrom")
      <*> (o .:? "image")
      <*> (o .:? "imagePullPolicy")
      <*> (o .:? "lifecycle")
      <*> (o .:? "livenessProbe")
      <*> (o .:? "mirrorVolumeMounts")
      <*> (o .:  "name")
      <*> (o .:? "ports")
      <*> (o .:? "readinessProbe")
      <*> (o .:? "resources")
      <*> (o .:? "securityContext")
      <*> (o .:? "stdin")
      <*> (o .:? "stdinOnce")
      <*> (o .:? "terminationMessagePath")
      <*> (o .:? "terminationMessagePolicy")
      <*> (o .:? "tty")
      <*> (o .:? "volumeDevices")
      <*> (o .:? "volumeMounts")
      <*> (o .:? "workingDir")

-- | ToJSON V1alpha1Sidecar
instance A.ToJSON V1alpha1Sidecar where
  toJSON V1alpha1Sidecar {..} =
   _omitNulls
      [ "args" .= v1alpha1SidecarArgs
      , "command" .= v1alpha1SidecarCommand
      , "env" .= v1alpha1SidecarEnv
      , "envFrom" .= v1alpha1SidecarEnvFrom
      , "image" .= v1alpha1SidecarImage
      , "imagePullPolicy" .= v1alpha1SidecarImagePullPolicy
      , "lifecycle" .= v1alpha1SidecarLifecycle
      , "livenessProbe" .= v1alpha1SidecarLivenessProbe
      , "mirrorVolumeMounts" .= v1alpha1SidecarMirrorVolumeMounts
      , "name" .= v1alpha1SidecarName
      , "ports" .= v1alpha1SidecarPorts
      , "readinessProbe" .= v1alpha1SidecarReadinessProbe
      , "resources" .= v1alpha1SidecarResources
      , "securityContext" .= v1alpha1SidecarSecurityContext
      , "stdin" .= v1alpha1SidecarStdin
      , "stdinOnce" .= v1alpha1SidecarStdinOnce
      , "terminationMessagePath" .= v1alpha1SidecarTerminationMessagePath
      , "terminationMessagePolicy" .= v1alpha1SidecarTerminationMessagePolicy
      , "tty" .= v1alpha1SidecarTty
      , "volumeDevices" .= v1alpha1SidecarVolumeDevices
      , "volumeMounts" .= v1alpha1SidecarVolumeMounts
      , "workingDir" .= v1alpha1SidecarWorkingDir
      ]


-- | Construct a value of type 'V1alpha1Sidecar' (by applying it's required fields, if any)
mkV1alpha1Sidecar
  :: Text -- ^ 'v1alpha1SidecarName': Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  -> V1alpha1Sidecar
mkV1alpha1Sidecar v1alpha1SidecarName =
  V1alpha1Sidecar
  { v1alpha1SidecarArgs = Nothing
  , v1alpha1SidecarCommand = Nothing
  , v1alpha1SidecarEnv = Nothing
  , v1alpha1SidecarEnvFrom = Nothing
  , v1alpha1SidecarImage = Nothing
  , v1alpha1SidecarImagePullPolicy = Nothing
  , v1alpha1SidecarLifecycle = Nothing
  , v1alpha1SidecarLivenessProbe = Nothing
  , v1alpha1SidecarMirrorVolumeMounts = Nothing
  , v1alpha1SidecarName
  , v1alpha1SidecarPorts = Nothing
  , v1alpha1SidecarReadinessProbe = Nothing
  , v1alpha1SidecarResources = Nothing
  , v1alpha1SidecarSecurityContext = Nothing
  , v1alpha1SidecarStdin = Nothing
  , v1alpha1SidecarStdinOnce = Nothing
  , v1alpha1SidecarTerminationMessagePath = Nothing
  , v1alpha1SidecarTerminationMessagePolicy = Nothing
  , v1alpha1SidecarTty = Nothing
  , v1alpha1SidecarVolumeDevices = Nothing
  , v1alpha1SidecarVolumeMounts = Nothing
  , v1alpha1SidecarWorkingDir = Nothing
  }

-- ** V1alpha1SuspendTemplate
-- | V1alpha1SuspendTemplate
-- SuspendTemplate is a template subtype to suspend a workflow at a predetermined point in time
data V1alpha1SuspendTemplate = V1alpha1SuspendTemplate
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1SuspendTemplate
instance A.FromJSON V1alpha1SuspendTemplate where
  parseJSON = A.withObject "V1alpha1SuspendTemplate" $ \o ->
    pure V1alpha1SuspendTemplate
      

-- | ToJSON V1alpha1SuspendTemplate
instance A.ToJSON V1alpha1SuspendTemplate where
  toJSON V1alpha1SuspendTemplate  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'V1alpha1SuspendTemplate' (by applying it's required fields, if any)
mkV1alpha1SuspendTemplate
  :: V1alpha1SuspendTemplate
mkV1alpha1SuspendTemplate =
  V1alpha1SuspendTemplate
  { 
  }

-- ** V1alpha1Template
-- | V1alpha1Template
-- Template is a reusable and composable unit of execution in a workflow
data V1alpha1Template = V1alpha1Template
  { v1alpha1TemplateActiveDeadlineSeconds :: !(Maybe Integer) -- ^ "activeDeadlineSeconds" - Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.
  , v1alpha1TemplateAffinity :: !(Maybe V1Affinity) -- ^ "affinity" - Affinity sets the pod&#39;s scheduling constraints Overrides the affinity set at the workflow level (if any)
  , v1alpha1TemplateArchiveLocation :: !(Maybe V1alpha1ArtifactLocation) -- ^ "archiveLocation" - Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the &lt;workflowname&gt;/&lt;nodename&gt; in the key.
  , v1alpha1TemplateContainer :: !(Maybe V1Container) -- ^ "container" - Container is the main container image to run in the pod
  , v1alpha1TemplateDaemon :: !(Maybe Bool) -- ^ "daemon" - Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness
  , v1alpha1TemplateDag :: !(Maybe V1alpha1DAGTemplate) -- ^ "dag" - DAG template subtype which runs a DAG
  , v1alpha1TemplateInputs :: !(Maybe V1alpha1Inputs) -- ^ "inputs" - Inputs describe what inputs parameters and artifacts are supplied to this template
  , v1alpha1TemplateMetadata :: !(Maybe V1alpha1Metadata) -- ^ "metadata" - Metdata sets the pods&#39;s metadata, i.e. annotations and labels
  , v1alpha1TemplateName :: !(Text) -- ^ /Required/ "name" - Name is the name of the template
  , v1alpha1TemplateNodeSelector :: !(Maybe (Map.Map String Text)) -- ^ "nodeSelector" - NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.
  , v1alpha1TemplateOutputs :: !(Maybe V1alpha1Outputs) -- ^ "outputs" - Outputs describe the parameters and artifacts that this template produces
  , v1alpha1TemplateParallelism :: !(Maybe Integer) -- ^ "parallelism" - Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.
  , v1alpha1TemplateResource :: !(Maybe V1alpha1ResourceTemplate) -- ^ "resource" - Resource template subtype which can run k8s resources
  , v1alpha1TemplateRetryStrategy :: !(Maybe V1alpha1RetryStrategy) -- ^ "retryStrategy" - RetryStrategy describes how to retry a template when it fails
  , v1alpha1TemplateScript :: !(Maybe V1alpha1ScriptTemplate) -- ^ "script" - Script runs a portion of code against an interpreter
  , v1alpha1TemplateSidecars :: !(Maybe [V1alpha1Sidecar]) -- ^ "sidecars" - Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes
  , v1alpha1TemplateSteps :: !(Maybe [[V1alpha1WorkflowStep]]) -- ^ "steps" - Steps define a series of sequential/parallel workflow steps
  , v1alpha1TemplateSuspend :: !(Maybe V1alpha1SuspendTemplate) -- ^ "suspend" - Suspend template subtype which can suspend a workflow when reaching the step
  , v1alpha1TemplateTolerations :: !(Maybe [V1Toleration]) -- ^ "tolerations" - Tolerations to apply to workflow pods.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Template
instance A.FromJSON V1alpha1Template where
  parseJSON = A.withObject "V1alpha1Template" $ \o ->
    V1alpha1Template
      <$> (o .:? "activeDeadlineSeconds")
      <*> (o .:? "affinity")
      <*> (o .:? "archiveLocation")
      <*> (o .:? "container")
      <*> (o .:? "daemon")
      <*> (o .:? "dag")
      <*> (o .:? "inputs")
      <*> (o .:? "metadata")
      <*> (o .:  "name")
      <*> (o .:? "nodeSelector")
      <*> (o .:? "outputs")
      <*> (o .:? "parallelism")
      <*> (o .:? "resource")
      <*> (o .:? "retryStrategy")
      <*> (o .:? "script")
      <*> (o .:? "sidecars")
      <*> (o .:? "steps")
      <*> (o .:? "suspend")
      <*> (o .:? "tolerations")

-- | ToJSON V1alpha1Template
instance A.ToJSON V1alpha1Template where
  toJSON V1alpha1Template {..} =
   _omitNulls
      [ "activeDeadlineSeconds" .= v1alpha1TemplateActiveDeadlineSeconds
      , "affinity" .= v1alpha1TemplateAffinity
      , "archiveLocation" .= v1alpha1TemplateArchiveLocation
      , "container" .= v1alpha1TemplateContainer
      , "daemon" .= v1alpha1TemplateDaemon
      , "dag" .= v1alpha1TemplateDag
      , "inputs" .= v1alpha1TemplateInputs
      , "metadata" .= v1alpha1TemplateMetadata
      , "name" .= v1alpha1TemplateName
      , "nodeSelector" .= v1alpha1TemplateNodeSelector
      , "outputs" .= v1alpha1TemplateOutputs
      , "parallelism" .= v1alpha1TemplateParallelism
      , "resource" .= v1alpha1TemplateResource
      , "retryStrategy" .= v1alpha1TemplateRetryStrategy
      , "script" .= v1alpha1TemplateScript
      , "sidecars" .= v1alpha1TemplateSidecars
      , "steps" .= v1alpha1TemplateSteps
      , "suspend" .= v1alpha1TemplateSuspend
      , "tolerations" .= v1alpha1TemplateTolerations
      ]


-- | Construct a value of type 'V1alpha1Template' (by applying it's required fields, if any)
mkV1alpha1Template
  :: Text -- ^ 'v1alpha1TemplateName': Name is the name of the template
  -> V1alpha1Template
mkV1alpha1Template v1alpha1TemplateName =
  V1alpha1Template
  { v1alpha1TemplateActiveDeadlineSeconds = Nothing
  , v1alpha1TemplateAffinity = Nothing
  , v1alpha1TemplateArchiveLocation = Nothing
  , v1alpha1TemplateContainer = Nothing
  , v1alpha1TemplateDaemon = Nothing
  , v1alpha1TemplateDag = Nothing
  , v1alpha1TemplateInputs = Nothing
  , v1alpha1TemplateMetadata = Nothing
  , v1alpha1TemplateName
  , v1alpha1TemplateNodeSelector = Nothing
  , v1alpha1TemplateOutputs = Nothing
  , v1alpha1TemplateParallelism = Nothing
  , v1alpha1TemplateResource = Nothing
  , v1alpha1TemplateRetryStrategy = Nothing
  , v1alpha1TemplateScript = Nothing
  , v1alpha1TemplateSidecars = Nothing
  , v1alpha1TemplateSteps = Nothing
  , v1alpha1TemplateSuspend = Nothing
  , v1alpha1TemplateTolerations = Nothing
  }

-- ** V1alpha1ValueFrom
-- | V1alpha1ValueFrom
-- ValueFrom describes a location in which to obtain the value to a parameter
data V1alpha1ValueFrom = V1alpha1ValueFrom
  { v1alpha1ValueFromJqFilter :: !(Maybe Text) -- ^ "jqFilter" - JQFilter expression against the resource object in resource templates
  , v1alpha1ValueFromJsonPath :: !(Maybe Text) -- ^ "jsonPath" - JSONPath of a resource to retrieve an output parameter value from in resource templates
  , v1alpha1ValueFromParameter :: !(Maybe Text) -- ^ "parameter" - Parameter reference to a step or dag task in which to retrieve an output parameter value from (e.g. &#39;{{steps.mystep.outputs.myparam}}&#39;)
  , v1alpha1ValueFromPath :: !(Maybe Text) -- ^ "path" - Path in the container to retrieve an output parameter value from in container templates
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1ValueFrom
instance A.FromJSON V1alpha1ValueFrom where
  parseJSON = A.withObject "V1alpha1ValueFrom" $ \o ->
    V1alpha1ValueFrom
      <$> (o .:? "jqFilter")
      <*> (o .:? "jsonPath")
      <*> (o .:? "parameter")
      <*> (o .:? "path")

-- | ToJSON V1alpha1ValueFrom
instance A.ToJSON V1alpha1ValueFrom where
  toJSON V1alpha1ValueFrom {..} =
   _omitNulls
      [ "jqFilter" .= v1alpha1ValueFromJqFilter
      , "jsonPath" .= v1alpha1ValueFromJsonPath
      , "parameter" .= v1alpha1ValueFromParameter
      , "path" .= v1alpha1ValueFromPath
      ]


-- | Construct a value of type 'V1alpha1ValueFrom' (by applying it's required fields, if any)
mkV1alpha1ValueFrom
  :: V1alpha1ValueFrom
mkV1alpha1ValueFrom =
  V1alpha1ValueFrom
  { v1alpha1ValueFromJqFilter = Nothing
  , v1alpha1ValueFromJsonPath = Nothing
  , v1alpha1ValueFromParameter = Nothing
  , v1alpha1ValueFromPath = Nothing
  }

-- ** V1alpha1Workflow
-- | V1alpha1Workflow
-- Workflow is the definition of a workflow resource
data V1alpha1Workflow = V1alpha1Workflow
  { v1alpha1WorkflowApiVersion :: !(Maybe Text) -- ^ "apiVersion" - APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
  , v1alpha1WorkflowKind :: !(Maybe Text) -- ^ "kind" - Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
  , v1alpha1WorkflowMetadata :: !(V1ObjectMeta) -- ^ /Required/ "metadata"
  , v1alpha1WorkflowSpec :: !(V1alpha1WorkflowSpec) -- ^ /Required/ "spec"
  , v1alpha1WorkflowStatus :: !(V1alpha1WorkflowStatus) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1Workflow
instance A.FromJSON V1alpha1Workflow where
  parseJSON = A.withObject "V1alpha1Workflow" $ \o ->
    V1alpha1Workflow
      <$> (o .:? "apiVersion")
      <*> (o .:? "kind")
      <*> (o .:  "metadata")
      <*> (o .:  "spec")
      <*> (o .:  "status")

-- | ToJSON V1alpha1Workflow
instance A.ToJSON V1alpha1Workflow where
  toJSON V1alpha1Workflow {..} =
   _omitNulls
      [ "apiVersion" .= v1alpha1WorkflowApiVersion
      , "kind" .= v1alpha1WorkflowKind
      , "metadata" .= v1alpha1WorkflowMetadata
      , "spec" .= v1alpha1WorkflowSpec
      , "status" .= v1alpha1WorkflowStatus
      ]


-- | Construct a value of type 'V1alpha1Workflow' (by applying it's required fields, if any)
mkV1alpha1Workflow
  :: V1ObjectMeta -- ^ 'v1alpha1WorkflowMetadata' 
  -> V1alpha1WorkflowSpec -- ^ 'v1alpha1WorkflowSpec' 
  -> V1alpha1WorkflowStatus -- ^ 'v1alpha1WorkflowStatus' 
  -> V1alpha1Workflow
mkV1alpha1Workflow v1alpha1WorkflowMetadata v1alpha1WorkflowSpec v1alpha1WorkflowStatus =
  V1alpha1Workflow
  { v1alpha1WorkflowApiVersion = Nothing
  , v1alpha1WorkflowKind = Nothing
  , v1alpha1WorkflowMetadata
  , v1alpha1WorkflowSpec
  , v1alpha1WorkflowStatus
  }

-- ** V1alpha1WorkflowList
-- | V1alpha1WorkflowList
-- WorkflowList is list of Workflow resources
data V1alpha1WorkflowList = V1alpha1WorkflowList
  { v1alpha1WorkflowListApiVersion :: !(Maybe Text) -- ^ "apiVersion" - APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
  , v1alpha1WorkflowListItems :: !([V1alpha1Workflow]) -- ^ /Required/ "items"
  , v1alpha1WorkflowListKind :: !(Maybe Text) -- ^ "kind" - Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
  , v1alpha1WorkflowListMetadata :: !(V1ListMeta) -- ^ /Required/ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1WorkflowList
instance A.FromJSON V1alpha1WorkflowList where
  parseJSON = A.withObject "V1alpha1WorkflowList" $ \o ->
    V1alpha1WorkflowList
      <$> (o .:? "apiVersion")
      <*> (o .:  "items")
      <*> (o .:? "kind")
      <*> (o .:  "metadata")

-- | ToJSON V1alpha1WorkflowList
instance A.ToJSON V1alpha1WorkflowList where
  toJSON V1alpha1WorkflowList {..} =
   _omitNulls
      [ "apiVersion" .= v1alpha1WorkflowListApiVersion
      , "items" .= v1alpha1WorkflowListItems
      , "kind" .= v1alpha1WorkflowListKind
      , "metadata" .= v1alpha1WorkflowListMetadata
      ]


-- | Construct a value of type 'V1alpha1WorkflowList' (by applying it's required fields, if any)
mkV1alpha1WorkflowList
  :: [V1alpha1Workflow] -- ^ 'v1alpha1WorkflowListItems' 
  -> V1ListMeta -- ^ 'v1alpha1WorkflowListMetadata' 
  -> V1alpha1WorkflowList
mkV1alpha1WorkflowList v1alpha1WorkflowListItems v1alpha1WorkflowListMetadata =
  V1alpha1WorkflowList
  { v1alpha1WorkflowListApiVersion = Nothing
  , v1alpha1WorkflowListItems
  , v1alpha1WorkflowListKind = Nothing
  , v1alpha1WorkflowListMetadata
  }

-- ** V1alpha1WorkflowSpec
-- | V1alpha1WorkflowSpec
-- WorkflowSpec is the specification of a Workflow.
data V1alpha1WorkflowSpec = V1alpha1WorkflowSpec
  { v1alpha1WorkflowSpecAffinity :: !(Maybe V1Affinity) -- ^ "affinity" - Affinity sets the scheduling constraints for all pods in the workflow. Can be overridden by an affinity specified in the template
  , v1alpha1WorkflowSpecArguments :: !(Maybe V1alpha1Arguments) -- ^ "arguments" - Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the &#39;workflow&#39; variable prefix. e.g. {{workflow.parameters.myparam}}
  , v1alpha1WorkflowSpecEntrypoint :: !(Text) -- ^ /Required/ "entrypoint" - Entrypoint is a template reference to the starting point of the workflow
  , v1alpha1WorkflowSpecImagePullSecrets :: !(Maybe [V1LocalObjectReference]) -- ^ "imagePullSecrets" - ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  , v1alpha1WorkflowSpecNodeSelector :: !(Maybe (Map.Map String Text)) -- ^ "nodeSelector" - NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.
  , v1alpha1WorkflowSpecOnExit :: !(Maybe Text) -- ^ "onExit" - OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary workflow.
  , v1alpha1WorkflowSpecParallelism :: !(Maybe Integer) -- ^ "parallelism" - Parallelism limits the max total parallel pods that can execute at the same time in a workflow
  , v1alpha1WorkflowSpecServiceAccountName :: !(Maybe Text) -- ^ "serviceAccountName" - ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
  , v1alpha1WorkflowSpecSuspend :: !(Maybe Bool) -- ^ "suspend" - Suspend will suspend the workflow and prevent execution of any future steps in the workflow
  , v1alpha1WorkflowSpecTemplates :: !([V1alpha1Template]) -- ^ /Required/ "templates" - Templates is a list of workflow templates used in a workflow
  , v1alpha1WorkflowSpecTolerations :: !(Maybe [V1Toleration]) -- ^ "tolerations" - Tolerations to apply to workflow pods.
  , v1alpha1WorkflowSpecVolumeClaimTemplates :: !(Maybe [V1PersistentVolumeClaim]) -- ^ "volumeClaimTemplates" - VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow
  , v1alpha1WorkflowSpecVolumes :: !(Maybe [V1Volume]) -- ^ "volumes" - Volumes is a list of volumes that can be mounted by containers in a workflow.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1WorkflowSpec
instance A.FromJSON V1alpha1WorkflowSpec where
  parseJSON = A.withObject "V1alpha1WorkflowSpec" $ \o ->
    V1alpha1WorkflowSpec
      <$> (o .:? "affinity")
      <*> (o .:? "arguments")
      <*> (o .:  "entrypoint")
      <*> (o .:? "imagePullSecrets")
      <*> (o .:? "nodeSelector")
      <*> (o .:? "onExit")
      <*> (o .:? "parallelism")
      <*> (o .:? "serviceAccountName")
      <*> (o .:? "suspend")
      <*> (o .:  "templates")
      <*> (o .:? "tolerations")
      <*> (o .:? "volumeClaimTemplates")
      <*> (o .:? "volumes")

-- | ToJSON V1alpha1WorkflowSpec
instance A.ToJSON V1alpha1WorkflowSpec where
  toJSON V1alpha1WorkflowSpec {..} =
   _omitNulls
      [ "affinity" .= v1alpha1WorkflowSpecAffinity
      , "arguments" .= v1alpha1WorkflowSpecArguments
      , "entrypoint" .= v1alpha1WorkflowSpecEntrypoint
      , "imagePullSecrets" .= v1alpha1WorkflowSpecImagePullSecrets
      , "nodeSelector" .= v1alpha1WorkflowSpecNodeSelector
      , "onExit" .= v1alpha1WorkflowSpecOnExit
      , "parallelism" .= v1alpha1WorkflowSpecParallelism
      , "serviceAccountName" .= v1alpha1WorkflowSpecServiceAccountName
      , "suspend" .= v1alpha1WorkflowSpecSuspend
      , "templates" .= v1alpha1WorkflowSpecTemplates
      , "tolerations" .= v1alpha1WorkflowSpecTolerations
      , "volumeClaimTemplates" .= v1alpha1WorkflowSpecVolumeClaimTemplates
      , "volumes" .= v1alpha1WorkflowSpecVolumes
      ]


-- | Construct a value of type 'V1alpha1WorkflowSpec' (by applying it's required fields, if any)
mkV1alpha1WorkflowSpec
  :: Text -- ^ 'v1alpha1WorkflowSpecEntrypoint': Entrypoint is a template reference to the starting point of the workflow
  -> [V1alpha1Template] -- ^ 'v1alpha1WorkflowSpecTemplates': Templates is a list of workflow templates used in a workflow
  -> V1alpha1WorkflowSpec
mkV1alpha1WorkflowSpec v1alpha1WorkflowSpecEntrypoint v1alpha1WorkflowSpecTemplates =
  V1alpha1WorkflowSpec
  { v1alpha1WorkflowSpecAffinity = Nothing
  , v1alpha1WorkflowSpecArguments = Nothing
  , v1alpha1WorkflowSpecEntrypoint
  , v1alpha1WorkflowSpecImagePullSecrets = Nothing
  , v1alpha1WorkflowSpecNodeSelector = Nothing
  , v1alpha1WorkflowSpecOnExit = Nothing
  , v1alpha1WorkflowSpecParallelism = Nothing
  , v1alpha1WorkflowSpecServiceAccountName = Nothing
  , v1alpha1WorkflowSpecSuspend = Nothing
  , v1alpha1WorkflowSpecTemplates
  , v1alpha1WorkflowSpecTolerations = Nothing
  , v1alpha1WorkflowSpecVolumeClaimTemplates = Nothing
  , v1alpha1WorkflowSpecVolumes = Nothing
  }

-- ** V1alpha1WorkflowStep
-- | V1alpha1WorkflowStep
-- WorkflowStep is a reference to a template to execute in a series of step
data V1alpha1WorkflowStep = V1alpha1WorkflowStep
  { v1alpha1WorkflowStepArguments :: !(Maybe V1alpha1Arguments) -- ^ "arguments" - Arguments hold arguments to the template
  , v1alpha1WorkflowStepName :: !(Maybe Text) -- ^ "name" - Name of the step
  , v1alpha1WorkflowStepTemplate :: !(Maybe Text) -- ^ "template" - Template is a reference to the template to execute as the step
  , v1alpha1WorkflowStepWhen :: !(Maybe Text) -- ^ "when" - When is an expression in which the step should conditionally execute
  , v1alpha1WorkflowStepWithItems :: !(Maybe [V1alpha1Item]) -- ^ "withItems" - WithItems expands a step into multiple parallel steps from the items in the list
  , v1alpha1WorkflowStepWithParam :: !(Maybe Text) -- ^ "withParam" - WithParam expands a step into from the value in the parameter
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1alpha1WorkflowStep
instance A.FromJSON V1alpha1WorkflowStep where
  parseJSON = A.withObject "V1alpha1WorkflowStep" $ \o ->
    V1alpha1WorkflowStep
      <$> (o .:? "arguments")
      <*> (o .:? "name")
      <*> (o .:? "template")
      <*> (o .:? "when")
      <*> (o .:? "withItems")
      <*> (o .:? "withParam")

-- | ToJSON V1alpha1WorkflowStep
instance A.ToJSON V1alpha1WorkflowStep where
  toJSON V1alpha1WorkflowStep {..} =
   _omitNulls
      [ "arguments" .= v1alpha1WorkflowStepArguments
      , "name" .= v1alpha1WorkflowStepName
      , "template" .= v1alpha1WorkflowStepTemplate
      , "when" .= v1alpha1WorkflowStepWhen
      , "withItems" .= v1alpha1WorkflowStepWithItems
      , "withParam" .= v1alpha1WorkflowStepWithParam
      ]


-- | Construct a value of type 'V1alpha1WorkflowStep' (by applying it's required fields, if any)
mkV1alpha1WorkflowStep
  :: V1alpha1WorkflowStep
mkV1alpha1WorkflowStep =
  V1alpha1WorkflowStep
  { v1alpha1WorkflowStepArguments = Nothing
  , v1alpha1WorkflowStepName = Nothing
  , v1alpha1WorkflowStepTemplate = Nothing
  , v1alpha1WorkflowStepWhen = Nothing
  , v1alpha1WorkflowStepWithItems = Nothing
  , v1alpha1WorkflowStepWithParam = Nothing
  }




