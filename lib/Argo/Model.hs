{-
   Argo

   No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

   OpenAPI spec version: 2.0
   Argo API version: v2.1.0
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : Argo.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Argo.Model where

import Argo.Core
import Argo.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** Arguments
-- | Arguments
-- Arguments to a template
data Arguments = Arguments
  { argumentsArtifacts :: !(Maybe [Artifact]) -- ^ "artifacts" - Artifacts is the list of artifacts to pass to the template or workflow
  , argumentsParameters :: !(Maybe [Parameter]) -- ^ "parameters" - Parameters is the list of parameters to pass to the template or workflow
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Arguments
instance A.FromJSON Arguments where
  parseJSON = A.withObject "Arguments" $ \o ->
    Arguments
      <$> (o .:? "artifacts")
      <*> (o .:? "parameters")

-- | ToJSON Arguments
instance A.ToJSON Arguments where
  toJSON Arguments {..} =
   _omitNulls
      [ "artifacts" .= argumentsArtifacts
      , "parameters" .= argumentsParameters
      ]


-- | Construct a value of type 'Arguments' (by applying it's required fields, if any)
mkArguments
  :: Arguments
mkArguments =
  Arguments
  { argumentsArtifacts = Nothing
  , argumentsParameters = Nothing
  }

-- ** Artifact
-- | Artifact
-- Artifact indicates an artifact to place at a specified path
data Artifact = Artifact
  { artifactArtifactory :: !(Maybe ArtifactoryArtifact) -- ^ "artifactory" - Artifactory contains artifactory artifact location details
  , artifactFrom :: !(Maybe Text) -- ^ "from" - From allows an artifact to reference an artifact from a previous step
  , artifactGit :: !(Maybe GitArtifact) -- ^ "git" - Git contains git artifact location details
  , artifactGlobalName :: !(Maybe Text) -- ^ "globalName" - GlobalName exports an output artifact to the global scope, making it available as &#39;{{workflow.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
  , artifactHttp :: !(Maybe HTTPArtifact) -- ^ "http" - HTTP contains HTTP artifact location details
  , artifactMode :: !(Maybe Int) -- ^ "mode" - mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts.
  , artifactName :: !(Text) -- ^ /Required/ "name" - name of the artifact. must be unique within a template&#39;s inputs/outputs.
  , artifactPath :: !(Maybe Text) -- ^ "path" - Path is the container path to the artifact
  , artifactRaw :: !(Maybe RawArtifact) -- ^ "raw" - Raw contains raw artifact location details
  , artifactS3 :: !(Maybe S3Artifact) -- ^ "s3" - S3 contains S3 artifact location details
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Artifact
instance A.FromJSON Artifact where
  parseJSON = A.withObject "Artifact" $ \o ->
    Artifact
      <$> (o .:? "artifactory")
      <*> (o .:? "from")
      <*> (o .:? "git")
      <*> (o .:? "globalName")
      <*> (o .:? "http")
      <*> (o .:? "mode")
      <*> (o .:  "name")
      <*> (o .:? "path")
      <*> (o .:? "raw")
      <*> (o .:? "s3")

-- | ToJSON Artifact
instance A.ToJSON Artifact where
  toJSON Artifact {..} =
   _omitNulls
      [ "artifactory" .= artifactArtifactory
      , "from" .= artifactFrom
      , "git" .= artifactGit
      , "globalName" .= artifactGlobalName
      , "http" .= artifactHttp
      , "mode" .= artifactMode
      , "name" .= artifactName
      , "path" .= artifactPath
      , "raw" .= artifactRaw
      , "s3" .= artifactS3
      ]


-- | Construct a value of type 'Artifact' (by applying it's required fields, if any)
mkArtifact
  :: Text -- ^ 'artifactName': name of the artifact. must be unique within a template's inputs/outputs.
  -> Artifact
mkArtifact artifactName =
  Artifact
  { artifactArtifactory = Nothing
  , artifactFrom = Nothing
  , artifactGit = Nothing
  , artifactGlobalName = Nothing
  , artifactHttp = Nothing
  , artifactMode = Nothing
  , artifactName
  , artifactPath = Nothing
  , artifactRaw = Nothing
  , artifactS3 = Nothing
  }

-- ** ArtifactLocation
-- | ArtifactLocation
-- ArtifactLocation describes a location for a single or multiple artifacts. It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname). It is also used to describe the location of multiple artifacts such as the archive location of a single workflow step, which the executor will use as a default location to store its files.
data ArtifactLocation = ArtifactLocation
  { artifactLocationArtifactory :: !(Maybe ArtifactoryArtifact) -- ^ "artifactory" - Artifactory contains artifactory artifact location details
  , artifactLocationGit :: !(Maybe GitArtifact) -- ^ "git" - Git contains git artifact location details
  , artifactLocationHttp :: !(Maybe HTTPArtifact) -- ^ "http" - HTTP contains HTTP artifact location details
  , artifactLocationRaw :: !(Maybe RawArtifact) -- ^ "raw" - Raw contains raw artifact location details
  , artifactLocationS3 :: !(Maybe S3Artifact) -- ^ "s3" - S3 contains S3 artifact location details
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ArtifactLocation
instance A.FromJSON ArtifactLocation where
  parseJSON = A.withObject "ArtifactLocation" $ \o ->
    ArtifactLocation
      <$> (o .:? "artifactory")
      <*> (o .:? "git")
      <*> (o .:? "http")
      <*> (o .:? "raw")
      <*> (o .:? "s3")

-- | ToJSON ArtifactLocation
instance A.ToJSON ArtifactLocation where
  toJSON ArtifactLocation {..} =
   _omitNulls
      [ "artifactory" .= artifactLocationArtifactory
      , "git" .= artifactLocationGit
      , "http" .= artifactLocationHttp
      , "raw" .= artifactLocationRaw
      , "s3" .= artifactLocationS3
      ]


-- | Construct a value of type 'ArtifactLocation' (by applying it's required fields, if any)
mkArtifactLocation
  :: ArtifactLocation
mkArtifactLocation =
  ArtifactLocation
  { artifactLocationArtifactory = Nothing
  , artifactLocationGit = Nothing
  , artifactLocationHttp = Nothing
  , artifactLocationRaw = Nothing
  , artifactLocationS3 = Nothing
  }

-- ** ArtifactoryArtifact
-- | ArtifactoryArtifact
-- ArtifactoryArtifact is the location of an artifactory artifact
data ArtifactoryArtifact = ArtifactoryArtifact
  { artifactoryArtifactPasswordSecret :: !(Maybe V1SecretKeySelector) -- ^ "passwordSecret" - PasswordSecret is the secret selector to the repository password
  , artifactoryArtifactUrl :: !(Text) -- ^ /Required/ "url" - URL of the artifact
  , artifactoryArtifactUsernameSecret :: !(Maybe V1SecretKeySelector) -- ^ "usernameSecret" - UsernameSecret is the secret selector to the repository username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ArtifactoryArtifact
instance A.FromJSON ArtifactoryArtifact where
  parseJSON = A.withObject "ArtifactoryArtifact" $ \o ->
    ArtifactoryArtifact
      <$> (o .:? "passwordSecret")
      <*> (o .:  "url")
      <*> (o .:? "usernameSecret")

-- | ToJSON ArtifactoryArtifact
instance A.ToJSON ArtifactoryArtifact where
  toJSON ArtifactoryArtifact {..} =
   _omitNulls
      [ "passwordSecret" .= artifactoryArtifactPasswordSecret
      , "url" .= artifactoryArtifactUrl
      , "usernameSecret" .= artifactoryArtifactUsernameSecret
      ]


-- | Construct a value of type 'ArtifactoryArtifact' (by applying it's required fields, if any)
mkArtifactoryArtifact
  :: Text -- ^ 'artifactoryArtifactUrl': URL of the artifact
  -> ArtifactoryArtifact
mkArtifactoryArtifact artifactoryArtifactUrl =
  ArtifactoryArtifact
  { artifactoryArtifactPasswordSecret = Nothing
  , artifactoryArtifactUrl
  , artifactoryArtifactUsernameSecret = Nothing
  }

-- ** ArtifactoryAuth
-- | ArtifactoryAuth
-- ArtifactoryAuth describes the secret selectors required for authenticating to artifactory
data ArtifactoryAuth = ArtifactoryAuth
  { artifactoryAuthPasswordSecret :: !(Maybe V1SecretKeySelector) -- ^ "passwordSecret" - PasswordSecret is the secret selector to the repository password
  , artifactoryAuthUsernameSecret :: !(Maybe V1SecretKeySelector) -- ^ "usernameSecret" - UsernameSecret is the secret selector to the repository username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ArtifactoryAuth
instance A.FromJSON ArtifactoryAuth where
  parseJSON = A.withObject "ArtifactoryAuth" $ \o ->
    ArtifactoryAuth
      <$> (o .:? "passwordSecret")
      <*> (o .:? "usernameSecret")

-- | ToJSON ArtifactoryAuth
instance A.ToJSON ArtifactoryAuth where
  toJSON ArtifactoryAuth {..} =
   _omitNulls
      [ "passwordSecret" .= artifactoryAuthPasswordSecret
      , "usernameSecret" .= artifactoryAuthUsernameSecret
      ]


-- | Construct a value of type 'ArtifactoryAuth' (by applying it's required fields, if any)
mkArtifactoryAuth
  :: ArtifactoryAuth
mkArtifactoryAuth =
  ArtifactoryAuth
  { artifactoryAuthPasswordSecret = Nothing
  , artifactoryAuthUsernameSecret = Nothing
  }

-- ** DAGTask
-- | DAGTask
-- DAGTask represents a node in the graph during DAG execution
data DAGTask = DAGTask
  { dAGTaskArguments :: !(Maybe Arguments) -- ^ "arguments" - Arguments are the parameter and artifact arguments to the template
  , dAGTaskDependencies :: !(Maybe [Text]) -- ^ "dependencies" - Dependencies are name of other targets which this depends on
  , dAGTaskName :: !(Text) -- ^ /Required/ "name" - Name is the name of the target
  , dAGTaskTemplate :: !(Text) -- ^ /Required/ "template" - Name of template to execute
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DAGTask
instance A.FromJSON DAGTask where
  parseJSON = A.withObject "DAGTask" $ \o ->
    DAGTask
      <$> (o .:? "arguments")
      <*> (o .:? "dependencies")
      <*> (o .:  "name")
      <*> (o .:  "template")

-- | ToJSON DAGTask
instance A.ToJSON DAGTask where
  toJSON DAGTask {..} =
   _omitNulls
      [ "arguments" .= dAGTaskArguments
      , "dependencies" .= dAGTaskDependencies
      , "name" .= dAGTaskName
      , "template" .= dAGTaskTemplate
      ]


-- | Construct a value of type 'DAGTask' (by applying it's required fields, if any)
mkDAGTask
  :: Text -- ^ 'dAGTaskName': Name is the name of the target
  -> Text -- ^ 'dAGTaskTemplate': Name of template to execute
  -> DAGTask
mkDAGTask dAGTaskName dAGTaskTemplate =
  DAGTask
  { dAGTaskArguments = Nothing
  , dAGTaskDependencies = Nothing
  , dAGTaskName
  , dAGTaskTemplate
  }

-- ** DAGTemplate
-- | DAGTemplate
-- DAGTemplate is a template subtype for directed acyclic graph templates
data DAGTemplate = DAGTemplate
  { dAGTemplateTarget :: !(Maybe Text) -- ^ "target" - Target are one or more names of targets to execute in a DAG
  , dAGTemplateTasks :: !([DAGTask]) -- ^ /Required/ "tasks" - Tasks are a list of DAG tasks
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DAGTemplate
instance A.FromJSON DAGTemplate where
  parseJSON = A.withObject "DAGTemplate" $ \o ->
    DAGTemplate
      <$> (o .:? "target")
      <*> (o .:  "tasks")

-- | ToJSON DAGTemplate
instance A.ToJSON DAGTemplate where
  toJSON DAGTemplate {..} =
   _omitNulls
      [ "target" .= dAGTemplateTarget
      , "tasks" .= dAGTemplateTasks
      ]


-- | Construct a value of type 'DAGTemplate' (by applying it's required fields, if any)
mkDAGTemplate
  :: [DAGTask] -- ^ 'dAGTemplateTasks': Tasks are a list of DAG tasks
  -> DAGTemplate
mkDAGTemplate dAGTemplateTasks =
  DAGTemplate
  { dAGTemplateTarget = Nothing
  , dAGTemplateTasks
  }

-- ** GitArtifact
-- | GitArtifact
-- GitArtifact is the location of an git artifact
data GitArtifact = GitArtifact
  { gitArtifactPasswordSecret :: !(Maybe V1SecretKeySelector) -- ^ "passwordSecret" - PasswordSecret is the secret selector to the repository password
  , gitArtifactRepo :: !(Text) -- ^ /Required/ "repo" - Repo is the git repository
  , gitArtifactRevision :: !(Maybe Text) -- ^ "revision" - Revision is the git commit, tag, branch to checkout
  , gitArtifactUsernameSecret :: !(Maybe V1SecretKeySelector) -- ^ "usernameSecret" - UsernameSecret is the secret selector to the repository username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitArtifact
instance A.FromJSON GitArtifact where
  parseJSON = A.withObject "GitArtifact" $ \o ->
    GitArtifact
      <$> (o .:? "passwordSecret")
      <*> (o .:  "repo")
      <*> (o .:? "revision")
      <*> (o .:? "usernameSecret")

-- | ToJSON GitArtifact
instance A.ToJSON GitArtifact where
  toJSON GitArtifact {..} =
   _omitNulls
      [ "passwordSecret" .= gitArtifactPasswordSecret
      , "repo" .= gitArtifactRepo
      , "revision" .= gitArtifactRevision
      , "usernameSecret" .= gitArtifactUsernameSecret
      ]


-- | Construct a value of type 'GitArtifact' (by applying it's required fields, if any)
mkGitArtifact
  :: Text -- ^ 'gitArtifactRepo': Repo is the git repository
  -> GitArtifact
mkGitArtifact gitArtifactRepo =
  GitArtifact
  { gitArtifactPasswordSecret = Nothing
  , gitArtifactRepo
  , gitArtifactRevision = Nothing
  , gitArtifactUsernameSecret = Nothing
  }

-- ** HTTPArtifact
-- | HTTPArtifact
-- HTTPArtifact allows an file served on HTTP to be placed as an input artifact in a container
data HTTPArtifact = HTTPArtifact
  { hTTPArtifactUrl :: !(Text) -- ^ /Required/ "url" - URL of the artifact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HTTPArtifact
instance A.FromJSON HTTPArtifact where
  parseJSON = A.withObject "HTTPArtifact" $ \o ->
    HTTPArtifact
      <$> (o .:  "url")

-- | ToJSON HTTPArtifact
instance A.ToJSON HTTPArtifact where
  toJSON HTTPArtifact {..} =
   _omitNulls
      [ "url" .= hTTPArtifactUrl
      ]


-- | Construct a value of type 'HTTPArtifact' (by applying it's required fields, if any)
mkHTTPArtifact
  :: Text -- ^ 'hTTPArtifactUrl': URL of the artifact
  -> HTTPArtifact
mkHTTPArtifact hTTPArtifactUrl =
  HTTPArtifact
  { hTTPArtifactUrl
  }

-- ** Inputs
-- | Inputs
-- Inputs are the mechanism for passing parameters, artifacts, volumes from one template to another
data Inputs = Inputs
  { inputsArtifacts :: !(Maybe [Artifact]) -- ^ "artifacts" - Artifact are a list of artifacts passed as inputs
  , inputsParameters :: !(Maybe [Parameter]) -- ^ "parameters" - Parameters are a list of parameters passed as inputs
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Inputs
instance A.FromJSON Inputs where
  parseJSON = A.withObject "Inputs" $ \o ->
    Inputs
      <$> (o .:? "artifacts")
      <*> (o .:? "parameters")

-- | ToJSON Inputs
instance A.ToJSON Inputs where
  toJSON Inputs {..} =
   _omitNulls
      [ "artifacts" .= inputsArtifacts
      , "parameters" .= inputsParameters
      ]


-- | Construct a value of type 'Inputs' (by applying it's required fields, if any)
mkInputs
  :: Inputs
mkInputs =
  Inputs
  { inputsArtifacts = Nothing
  , inputsParameters = Nothing
  }

-- ** Item
-- | Item
newtype Item = Item
  { unItem :: Text
  } deriving (P.Eq, P.Show, P.Typeable, A.ToJSON, A.FromJSON, WH.ToHttpApiData, WH.FromHttpApiData)


-- ** Metadata
-- | Metadata
-- Pod metdata
data Metadata = Metadata
  { metadataAnnotations :: !(Maybe (Map.Map String Text)) -- ^ "annotations"
  , metadataLabels :: !(Maybe (Map.Map String Text)) -- ^ "labels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Metadata
instance A.FromJSON Metadata where
  parseJSON = A.withObject "Metadata" $ \o ->
    Metadata
      <$> (o .:? "annotations")
      <*> (o .:? "labels")

-- | ToJSON Metadata
instance A.ToJSON Metadata where
  toJSON Metadata {..} =
   _omitNulls
      [ "annotations" .= metadataAnnotations
      , "labels" .= metadataLabels
      ]


-- | Construct a value of type 'Metadata' (by applying it's required fields, if any)
mkMetadata
  :: Metadata
mkMetadata =
  Metadata
  { metadataAnnotations = Nothing
  , metadataLabels = Nothing
  }

-- ** Outputs
-- | Outputs
-- Outputs hold parameters, artifacts, and results from a step
data Outputs = Outputs
  { outputsArtifacts :: !(Maybe [Artifact]) -- ^ "artifacts" - Artifacts holds the list of output artifacts produced by a step
  , outputsParameters :: !(Maybe [Parameter]) -- ^ "parameters" - Parameters holds the list of output parameters produced by a step
  , outputsResult :: !(Maybe Text) -- ^ "result" - Result holds the result (stdout) of a script template
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Outputs
instance A.FromJSON Outputs where
  parseJSON = A.withObject "Outputs" $ \o ->
    Outputs
      <$> (o .:? "artifacts")
      <*> (o .:? "parameters")
      <*> (o .:? "result")

-- | ToJSON Outputs
instance A.ToJSON Outputs where
  toJSON Outputs {..} =
   _omitNulls
      [ "artifacts" .= outputsArtifacts
      , "parameters" .= outputsParameters
      , "result" .= outputsResult
      ]


-- | Construct a value of type 'Outputs' (by applying it's required fields, if any)
mkOutputs
  :: Outputs
mkOutputs =
  Outputs
  { outputsArtifacts = Nothing
  , outputsParameters = Nothing
  , outputsResult = Nothing
  }

-- ** Parameter
-- | Parameter
-- Parameter indicate a passed string parameter to a service template with an optional default value
data Parameter = Parameter
  { parameterDefault :: !(Maybe Text) -- ^ "default" - Default is the default value to use for an input parameter if a value was not supplied
  , parameterGlobalName :: !(Maybe Text) -- ^ "globalName" - GlobalName exports an output parameter to the global scope, making it available as &#39;{{workflow.outputs.parameters.XXXX}} and in workflow.status.outputs.parameters
  , parameterName :: !(Text) -- ^ /Required/ "name" - Name is the parameter name
  , parameterValue :: !(Maybe Text) -- ^ "value" - Value is the literal value to use for the parameter. If specified in the context of an input parameter, the value takes precedence over any passed values
  , parameterValueFrom :: !(Maybe ValueFrom) -- ^ "valueFrom" - ValueFrom is the source for the output parameter&#39;s value
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Parameter
instance A.FromJSON Parameter where
  parseJSON = A.withObject "Parameter" $ \o ->
    Parameter
      <$> (o .:? "default")
      <*> (o .:? "globalName")
      <*> (o .:  "name")
      <*> (o .:? "value")
      <*> (o .:? "valueFrom")

-- | ToJSON Parameter
instance A.ToJSON Parameter where
  toJSON Parameter {..} =
   _omitNulls
      [ "default" .= parameterDefault
      , "globalName" .= parameterGlobalName
      , "name" .= parameterName
      , "value" .= parameterValue
      , "valueFrom" .= parameterValueFrom
      ]


-- | Construct a value of type 'Parameter' (by applying it's required fields, if any)
mkParameter
  :: Text -- ^ 'parameterName': Name is the parameter name
  -> Parameter
mkParameter parameterName =
  Parameter
  { parameterDefault = Nothing
  , parameterGlobalName = Nothing
  , parameterName
  , parameterValue = Nothing
  , parameterValueFrom = Nothing
  }

-- ** RawArtifact
-- | RawArtifact
-- RawArtifact allows raw string content to be placed as an artifact in a container
data RawArtifact = RawArtifact
  { rawArtifactData :: !(Text) -- ^ /Required/ "data" - Data is the string contents of the artifact
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RawArtifact
instance A.FromJSON RawArtifact where
  parseJSON = A.withObject "RawArtifact" $ \o ->
    RawArtifact
      <$> (o .:  "data")

-- | ToJSON RawArtifact
instance A.ToJSON RawArtifact where
  toJSON RawArtifact {..} =
   _omitNulls
      [ "data" .= rawArtifactData
      ]


-- | Construct a value of type 'RawArtifact' (by applying it's required fields, if any)
mkRawArtifact
  :: Text -- ^ 'rawArtifactData': Data is the string contents of the artifact
  -> RawArtifact
mkRawArtifact rawArtifactData =
  RawArtifact
  { rawArtifactData
  }

-- ** ResourceTemplate
-- | ResourceTemplate
-- ResourceTemplate is a template subtype to manipulate kubernetes resources
data ResourceTemplate = ResourceTemplate
  { resourceTemplateAction :: !(Text) -- ^ /Required/ "action" - Action is the action to perform to the resource. Must be one of: get, create, apply, delete, replace
  , resourceTemplateFailureCondition :: !(Maybe Text) -- ^ "failureCondition" - FailureCondition is a label selector expression which describes the conditions of the k8s resource in which the step was considered failed
  , resourceTemplateManifest :: !(Text) -- ^ /Required/ "manifest" - Manifest contains the kubernetes manifest
  , resourceTemplateSuccessCondition :: !(Maybe Text) -- ^ "successCondition" - SuccessCondition is a label selector expression which describes the conditions of the k8s resource in which it is acceptable to proceed to the following step
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceTemplate
instance A.FromJSON ResourceTemplate where
  parseJSON = A.withObject "ResourceTemplate" $ \o ->
    ResourceTemplate
      <$> (o .:  "action")
      <*> (o .:? "failureCondition")
      <*> (o .:  "manifest")
      <*> (o .:? "successCondition")

-- | ToJSON ResourceTemplate
instance A.ToJSON ResourceTemplate where
  toJSON ResourceTemplate {..} =
   _omitNulls
      [ "action" .= resourceTemplateAction
      , "failureCondition" .= resourceTemplateFailureCondition
      , "manifest" .= resourceTemplateManifest
      , "successCondition" .= resourceTemplateSuccessCondition
      ]


-- | Construct a value of type 'ResourceTemplate' (by applying it's required fields, if any)
mkResourceTemplate
  :: Text -- ^ 'resourceTemplateAction': Action is the action to perform to the resource. Must be one of: get, create, apply, delete, replace
  -> Text -- ^ 'resourceTemplateManifest': Manifest contains the kubernetes manifest
  -> ResourceTemplate
mkResourceTemplate resourceTemplateAction resourceTemplateManifest =
  ResourceTemplate
  { resourceTemplateAction
  , resourceTemplateFailureCondition = Nothing
  , resourceTemplateManifest
  , resourceTemplateSuccessCondition = Nothing
  }

-- ** RetryStrategy
-- | RetryStrategy
-- RetryStrategy provides controls on how to retry a workflow step
data RetryStrategy = RetryStrategy
  { retryStrategyLimit :: !(Maybe Int) -- ^ "limit" - Limit is the maximum number of attempts when retrying a container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetryStrategy
instance A.FromJSON RetryStrategy where
  parseJSON = A.withObject "RetryStrategy" $ \o ->
    RetryStrategy
      <$> (o .:? "limit")

-- | ToJSON RetryStrategy
instance A.ToJSON RetryStrategy where
  toJSON RetryStrategy {..} =
   _omitNulls
      [ "limit" .= retryStrategyLimit
      ]


-- | Construct a value of type 'RetryStrategy' (by applying it's required fields, if any)
mkRetryStrategy
  :: RetryStrategy
mkRetryStrategy =
  RetryStrategy
  { retryStrategyLimit = Nothing
  }

-- ** S3Artifact
-- | S3Artifact
-- S3Artifact is the location of an S3 artifact
data S3Artifact = S3Artifact
  { s3ArtifactAccessKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "accessKeySecret" - AccessKeySecret is the secret selector to the bucket&#39;s access key
  , s3ArtifactBucket :: !(Text) -- ^ /Required/ "bucket" - Bucket is the name of the bucket
  , s3ArtifactEndpoint :: !(Text) -- ^ /Required/ "endpoint" - Endpoint is the hostname of the bucket endpoint
  , s3ArtifactInsecure :: !(Maybe Bool) -- ^ "insecure" - Insecure will connect to the service with TLS
  , s3ArtifactKey :: !(Text) -- ^ /Required/ "key" - Key is the key in the bucket where the artifact resides
  , s3ArtifactRegion :: !(Maybe Text) -- ^ "region" - Region contains the optional bucket region
  , s3ArtifactSecretKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "secretKeySecret" - SecretKeySecret is the secret selector to the bucket&#39;s secret key
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON S3Artifact
instance A.FromJSON S3Artifact where
  parseJSON = A.withObject "S3Artifact" $ \o ->
    S3Artifact
      <$> (o .:  "accessKeySecret")
      <*> (o .:  "bucket")
      <*> (o .:  "endpoint")
      <*> (o .:? "insecure")
      <*> (o .:  "key")
      <*> (o .:? "region")
      <*> (o .:  "secretKeySecret")

-- | ToJSON S3Artifact
instance A.ToJSON S3Artifact where
  toJSON S3Artifact {..} =
   _omitNulls
      [ "accessKeySecret" .= s3ArtifactAccessKeySecret
      , "bucket" .= s3ArtifactBucket
      , "endpoint" .= s3ArtifactEndpoint
      , "insecure" .= s3ArtifactInsecure
      , "key" .= s3ArtifactKey
      , "region" .= s3ArtifactRegion
      , "secretKeySecret" .= s3ArtifactSecretKeySecret
      ]


-- | Construct a value of type 'S3Artifact' (by applying it's required fields, if any)
mkS3Artifact
  :: V1SecretKeySelector -- ^ 's3ArtifactAccessKeySecret': AccessKeySecret is the secret selector to the bucket's access key
  -> Text -- ^ 's3ArtifactBucket': Bucket is the name of the bucket
  -> Text -- ^ 's3ArtifactEndpoint': Endpoint is the hostname of the bucket endpoint
  -> Text -- ^ 's3ArtifactKey': Key is the key in the bucket where the artifact resides
  -> V1SecretKeySelector -- ^ 's3ArtifactSecretKeySecret': SecretKeySecret is the secret selector to the bucket's secret key
  -> S3Artifact
mkS3Artifact s3ArtifactAccessKeySecret s3ArtifactBucket s3ArtifactEndpoint s3ArtifactKey s3ArtifactSecretKeySecret =
  S3Artifact
  { s3ArtifactAccessKeySecret
  , s3ArtifactBucket
  , s3ArtifactEndpoint
  , s3ArtifactInsecure = Nothing
  , s3ArtifactKey
  , s3ArtifactRegion = Nothing
  , s3ArtifactSecretKeySecret
  }

-- ** S3Bucket
-- | S3Bucket
-- S3Bucket contains the access information required for interfacing with an S3 bucket
data S3Bucket = S3Bucket
  { s3BucketAccessKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "accessKeySecret" - AccessKeySecret is the secret selector to the bucket&#39;s access key
  , s3BucketBucket :: !(Text) -- ^ /Required/ "bucket" - Bucket is the name of the bucket
  , s3BucketEndpoint :: !(Text) -- ^ /Required/ "endpoint" - Endpoint is the hostname of the bucket endpoint
  , s3BucketInsecure :: !(Maybe Bool) -- ^ "insecure" - Insecure will connect to the service with TLS
  , s3BucketRegion :: !(Maybe Text) -- ^ "region" - Region contains the optional bucket region
  , s3BucketSecretKeySecret :: !(V1SecretKeySelector) -- ^ /Required/ "secretKeySecret" - SecretKeySecret is the secret selector to the bucket&#39;s secret key
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON S3Bucket
instance A.FromJSON S3Bucket where
  parseJSON = A.withObject "S3Bucket" $ \o ->
    S3Bucket
      <$> (o .:  "accessKeySecret")
      <*> (o .:  "bucket")
      <*> (o .:  "endpoint")
      <*> (o .:? "insecure")
      <*> (o .:? "region")
      <*> (o .:  "secretKeySecret")

-- | ToJSON S3Bucket
instance A.ToJSON S3Bucket where
  toJSON S3Bucket {..} =
   _omitNulls
      [ "accessKeySecret" .= s3BucketAccessKeySecret
      , "bucket" .= s3BucketBucket
      , "endpoint" .= s3BucketEndpoint
      , "insecure" .= s3BucketInsecure
      , "region" .= s3BucketRegion
      , "secretKeySecret" .= s3BucketSecretKeySecret
      ]


-- | Construct a value of type 'S3Bucket' (by applying it's required fields, if any)
mkS3Bucket
  :: V1SecretKeySelector -- ^ 's3BucketAccessKeySecret': AccessKeySecret is the secret selector to the bucket's access key
  -> Text -- ^ 's3BucketBucket': Bucket is the name of the bucket
  -> Text -- ^ 's3BucketEndpoint': Endpoint is the hostname of the bucket endpoint
  -> V1SecretKeySelector -- ^ 's3BucketSecretKeySecret': SecretKeySecret is the secret selector to the bucket's secret key
  -> S3Bucket
mkS3Bucket s3BucketAccessKeySecret s3BucketBucket s3BucketEndpoint s3BucketSecretKeySecret =
  S3Bucket
  { s3BucketAccessKeySecret
  , s3BucketBucket
  , s3BucketEndpoint
  , s3BucketInsecure = Nothing
  , s3BucketRegion = Nothing
  , s3BucketSecretKeySecret
  }

-- ** ScriptTemplate
-- | ScriptTemplate
-- ScriptTemplate is a template subtype to enable scripting through code steps
data ScriptTemplate = ScriptTemplate
  { scriptTemplateArgs :: !(Maybe [Text]) -- ^ "args" - Arguments to the entrypoint. The docker image&#39;s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , scriptTemplateCommand :: !(Maybe [Text]) -- ^ "command" - Entrypoint array. Not executed within a shell. The docker image&#39;s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , scriptTemplateEnv :: !(Maybe [V1EnvVar]) -- ^ "env" - List of environment variables to set in the container. Cannot be updated.
  , scriptTemplateEnvFrom :: !(Maybe [V1EnvFromSource]) -- ^ "envFrom" - List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
  , scriptTemplateImage :: !(Maybe Text) -- ^ "image" - Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
  , scriptTemplateImagePullPolicy :: !(Maybe Text) -- ^ "imagePullPolicy" - Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  , scriptTemplateLifecycle :: !(Maybe V1Lifecycle) -- ^ "lifecycle" - Actions that the management system should take in response to container lifecycle events. Cannot be updated.
  , scriptTemplateLivenessProbe :: !(Maybe V1Probe) -- ^ "livenessProbe" - Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , scriptTemplateName :: !(Text) -- ^ /Required/ "name" - Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  , scriptTemplatePorts :: !(Maybe [V1ContainerPort]) -- ^ "ports" - List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \&quot;0.0.0.0\&quot; address inside a container will be accessible from the network. Cannot be updated.
  , scriptTemplateReadinessProbe :: !(Maybe V1Probe) -- ^ "readinessProbe" - Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , scriptTemplateResources :: !(Maybe V1ResourceRequirements) -- ^ "resources" - Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  , scriptTemplateSecurityContext :: !(Maybe V1SecurityContext) -- ^ "securityContext" - Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  , scriptTemplateSource :: !(Text) -- ^ /Required/ "source" - Source contains the source code of the script to execute
  , scriptTemplateStdin :: !(Maybe Bool) -- ^ "stdin" - Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
  , scriptTemplateStdinOnce :: !(Maybe Bool) -- ^ "stdinOnce" - Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
  , scriptTemplateTerminationMessagePath :: !(Maybe Text) -- ^ "terminationMessagePath" - Optional: Path at which the file to which the container&#39;s termination message will be written is mounted into the container&#39;s filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
  , scriptTemplateTerminationMessagePolicy :: !(Maybe Text) -- ^ "terminationMessagePolicy" - Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
  , scriptTemplateTty :: !(Maybe Bool) -- ^ "tty" - Whether this container should allocate a TTY for itself, also requires &#39;stdin&#39; to be true. Default is false.
  , scriptTemplateVolumeDevices :: !(Maybe [V1VolumeDevice]) -- ^ "volumeDevices" - volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.
  , scriptTemplateVolumeMounts :: !(Maybe [V1VolumeMount]) -- ^ "volumeMounts" - Pod volumes to mount into the container&#39;s filesystem. Cannot be updated.
  , scriptTemplateWorkingDir :: !(Maybe Text) -- ^ "workingDir" - Container&#39;s working directory. If not specified, the container runtime&#39;s default will be used, which might be configured in the container image. Cannot be updated.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScriptTemplate
instance A.FromJSON ScriptTemplate where
  parseJSON = A.withObject "ScriptTemplate" $ \o ->
    ScriptTemplate
      <$> (o .:? "args")
      <*> (o .:? "command")
      <*> (o .:? "env")
      <*> (o .:? "envFrom")
      <*> (o .:? "image")
      <*> (o .:? "imagePullPolicy")
      <*> (o .:? "lifecycle")
      <*> (o .:? "livenessProbe")
      <*> (o .:  "name")
      <*> (o .:? "ports")
      <*> (o .:? "readinessProbe")
      <*> (o .:? "resources")
      <*> (o .:? "securityContext")
      <*> (o .:  "source")
      <*> (o .:? "stdin")
      <*> (o .:? "stdinOnce")
      <*> (o .:? "terminationMessagePath")
      <*> (o .:? "terminationMessagePolicy")
      <*> (o .:? "tty")
      <*> (o .:? "volumeDevices")
      <*> (o .:? "volumeMounts")
      <*> (o .:? "workingDir")

-- | ToJSON ScriptTemplate
instance A.ToJSON ScriptTemplate where
  toJSON ScriptTemplate {..} =
   _omitNulls
      [ "args" .= scriptTemplateArgs
      , "command" .= scriptTemplateCommand
      , "env" .= scriptTemplateEnv
      , "envFrom" .= scriptTemplateEnvFrom
      , "image" .= scriptTemplateImage
      , "imagePullPolicy" .= scriptTemplateImagePullPolicy
      , "lifecycle" .= scriptTemplateLifecycle
      , "livenessProbe" .= scriptTemplateLivenessProbe
      , "name" .= scriptTemplateName
      , "ports" .= scriptTemplatePorts
      , "readinessProbe" .= scriptTemplateReadinessProbe
      , "resources" .= scriptTemplateResources
      , "securityContext" .= scriptTemplateSecurityContext
      , "source" .= scriptTemplateSource
      , "stdin" .= scriptTemplateStdin
      , "stdinOnce" .= scriptTemplateStdinOnce
      , "terminationMessagePath" .= scriptTemplateTerminationMessagePath
      , "terminationMessagePolicy" .= scriptTemplateTerminationMessagePolicy
      , "tty" .= scriptTemplateTty
      , "volumeDevices" .= scriptTemplateVolumeDevices
      , "volumeMounts" .= scriptTemplateVolumeMounts
      , "workingDir" .= scriptTemplateWorkingDir
      ]


-- | Construct a value of type 'ScriptTemplate' (by applying it's required fields, if any)
mkScriptTemplate
  :: Text -- ^ 'scriptTemplateName': Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  -> Text -- ^ 'scriptTemplateSource': Source contains the source code of the script to execute
  -> ScriptTemplate
mkScriptTemplate scriptTemplateName scriptTemplateSource =
  ScriptTemplate
  { scriptTemplateArgs = Nothing
  , scriptTemplateCommand = Nothing
  , scriptTemplateEnv = Nothing
  , scriptTemplateEnvFrom = Nothing
  , scriptTemplateImage = Nothing
  , scriptTemplateImagePullPolicy = Nothing
  , scriptTemplateLifecycle = Nothing
  , scriptTemplateLivenessProbe = Nothing
  , scriptTemplateName
  , scriptTemplatePorts = Nothing
  , scriptTemplateReadinessProbe = Nothing
  , scriptTemplateResources = Nothing
  , scriptTemplateSecurityContext = Nothing
  , scriptTemplateSource
  , scriptTemplateStdin = Nothing
  , scriptTemplateStdinOnce = Nothing
  , scriptTemplateTerminationMessagePath = Nothing
  , scriptTemplateTerminationMessagePolicy = Nothing
  , scriptTemplateTty = Nothing
  , scriptTemplateVolumeDevices = Nothing
  , scriptTemplateVolumeMounts = Nothing
  , scriptTemplateWorkingDir = Nothing
  }

-- ** Sidecar
-- | Sidecar
-- Sidecar is a container which runs alongside the main container
data Sidecar = Sidecar
  { sidecarArgs :: !(Maybe [Text]) -- ^ "args" - Arguments to the entrypoint. The docker image&#39;s CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , sidecarCommand :: !(Maybe [Text]) -- ^ "command" - Entrypoint array. Not executed within a shell. The docker image&#39;s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container&#39;s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  , sidecarEnv :: !(Maybe [V1EnvVar]) -- ^ "env" - List of environment variables to set in the container. Cannot be updated.
  , sidecarEnvFrom :: !(Maybe [V1EnvFromSource]) -- ^ "envFrom" - List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
  , sidecarImage :: !(Maybe Text) -- ^ "image" - Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
  , sidecarImagePullPolicy :: !(Maybe Text) -- ^ "imagePullPolicy" - Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  , sidecarLifecycle :: !(Maybe V1Lifecycle) -- ^ "lifecycle" - Actions that the management system should take in response to container lifecycle events. Cannot be updated.
  , sidecarLivenessProbe :: !(Maybe V1Probe) -- ^ "livenessProbe" - Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , sidecarMirrorVolumeMounts :: !(Maybe Bool) -- ^ "mirrorVolumeMounts" - MirrorVolumeMounts will mount the same volumes specified in the main container to the sidecar (including artifacts), at the same mountPaths. This enables dind daemon to partially see the same filesystem as the main container in order to use features such as docker volume binding
  , sidecarName :: !(Text) -- ^ /Required/ "name" - Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  , sidecarPorts :: !(Maybe [V1ContainerPort]) -- ^ "ports" - List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \&quot;0.0.0.0\&quot; address inside a container will be accessible from the network. Cannot be updated.
  , sidecarReadinessProbe :: !(Maybe V1Probe) -- ^ "readinessProbe" - Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  , sidecarResources :: !(Maybe V1ResourceRequirements) -- ^ "resources" - Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  , sidecarSecurityContext :: !(Maybe V1SecurityContext) -- ^ "securityContext" - Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  , sidecarStdin :: !(Maybe Bool) -- ^ "stdin" - Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
  , sidecarStdinOnce :: !(Maybe Bool) -- ^ "stdinOnce" - Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
  , sidecarTerminationMessagePath :: !(Maybe Text) -- ^ "terminationMessagePath" - Optional: Path at which the file to which the container&#39;s termination message will be written is mounted into the container&#39;s filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
  , sidecarTerminationMessagePolicy :: !(Maybe Text) -- ^ "terminationMessagePolicy" - Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
  , sidecarTty :: !(Maybe Bool) -- ^ "tty" - Whether this container should allocate a TTY for itself, also requires &#39;stdin&#39; to be true. Default is false.
  , sidecarVolumeDevices :: !(Maybe [V1VolumeDevice]) -- ^ "volumeDevices" - volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.
  , sidecarVolumeMounts :: !(Maybe [V1VolumeMount]) -- ^ "volumeMounts" - Pod volumes to mount into the container&#39;s filesystem. Cannot be updated.
  , sidecarWorkingDir :: !(Maybe Text) -- ^ "workingDir" - Container&#39;s working directory. If not specified, the container runtime&#39;s default will be used, which might be configured in the container image. Cannot be updated.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Sidecar
instance A.FromJSON Sidecar where
  parseJSON = A.withObject "Sidecar" $ \o ->
    Sidecar
      <$> (o .:? "args")
      <*> (o .:? "command")
      <*> (o .:? "env")
      <*> (o .:? "envFrom")
      <*> (o .:? "image")
      <*> (o .:? "imagePullPolicy")
      <*> (o .:? "lifecycle")
      <*> (o .:? "livenessProbe")
      <*> (o .:? "mirrorVolumeMounts")
      <*> (o .:  "name")
      <*> (o .:? "ports")
      <*> (o .:? "readinessProbe")
      <*> (o .:? "resources")
      <*> (o .:? "securityContext")
      <*> (o .:? "stdin")
      <*> (o .:? "stdinOnce")
      <*> (o .:? "terminationMessagePath")
      <*> (o .:? "terminationMessagePolicy")
      <*> (o .:? "tty")
      <*> (o .:? "volumeDevices")
      <*> (o .:? "volumeMounts")
      <*> (o .:? "workingDir")

-- | ToJSON Sidecar
instance A.ToJSON Sidecar where
  toJSON Sidecar {..} =
   _omitNulls
      [ "args" .= sidecarArgs
      , "command" .= sidecarCommand
      , "env" .= sidecarEnv
      , "envFrom" .= sidecarEnvFrom
      , "image" .= sidecarImage
      , "imagePullPolicy" .= sidecarImagePullPolicy
      , "lifecycle" .= sidecarLifecycle
      , "livenessProbe" .= sidecarLivenessProbe
      , "mirrorVolumeMounts" .= sidecarMirrorVolumeMounts
      , "name" .= sidecarName
      , "ports" .= sidecarPorts
      , "readinessProbe" .= sidecarReadinessProbe
      , "resources" .= sidecarResources
      , "securityContext" .= sidecarSecurityContext
      , "stdin" .= sidecarStdin
      , "stdinOnce" .= sidecarStdinOnce
      , "terminationMessagePath" .= sidecarTerminationMessagePath
      , "terminationMessagePolicy" .= sidecarTerminationMessagePolicy
      , "tty" .= sidecarTty
      , "volumeDevices" .= sidecarVolumeDevices
      , "volumeMounts" .= sidecarVolumeMounts
      , "workingDir" .= sidecarWorkingDir
      ]


-- | Construct a value of type 'Sidecar' (by applying it's required fields, if any)
mkSidecar
  :: Text -- ^ 'sidecarName': Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
  -> Sidecar
mkSidecar sidecarName =
  Sidecar
  { sidecarArgs = Nothing
  , sidecarCommand = Nothing
  , sidecarEnv = Nothing
  , sidecarEnvFrom = Nothing
  , sidecarImage = Nothing
  , sidecarImagePullPolicy = Nothing
  , sidecarLifecycle = Nothing
  , sidecarLivenessProbe = Nothing
  , sidecarMirrorVolumeMounts = Nothing
  , sidecarName
  , sidecarPorts = Nothing
  , sidecarReadinessProbe = Nothing
  , sidecarResources = Nothing
  , sidecarSecurityContext = Nothing
  , sidecarStdin = Nothing
  , sidecarStdinOnce = Nothing
  , sidecarTerminationMessagePath = Nothing
  , sidecarTerminationMessagePolicy = Nothing
  , sidecarTty = Nothing
  , sidecarVolumeDevices = Nothing
  , sidecarVolumeMounts = Nothing
  , sidecarWorkingDir = Nothing
  }

-- ** SuspendTemplate
-- | SuspendTemplate
-- SuspendTemplate is a template subtype to suspend a workflow at a predetermined point in time
data SuspendTemplate = SuspendTemplate
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SuspendTemplate
instance A.FromJSON SuspendTemplate where
  parseJSON = A.withObject "SuspendTemplate" $ \o ->
    pure SuspendTemplate
      

-- | ToJSON SuspendTemplate
instance A.ToJSON SuspendTemplate where
  toJSON SuspendTemplate  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'SuspendTemplate' (by applying it's required fields, if any)
mkSuspendTemplate
  :: SuspendTemplate
mkSuspendTemplate =
  SuspendTemplate
  { 
  }

-- ** Template
-- | Template
-- Template is a reusable and composable unit of execution in a workflow
data Template = Template
  { templateActiveDeadlineSeconds :: !(Maybe Integer) -- ^ "activeDeadlineSeconds" - Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.
  , templateAffinity :: !(Maybe V1Affinity) -- ^ "affinity" - Affinity sets the pod&#39;s scheduling constraints Overrides the affinity set at the workflow level (if any)
  , templateArchiveLocation :: !(Maybe ArtifactLocation) -- ^ "archiveLocation" - Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the &lt;workflowname&gt;/&lt;nodename&gt; in the key.
  , templateContainer :: !(Maybe V1Container) -- ^ "container" - Container is the main container image to run in the pod
  , templateDaemon :: !(Maybe Bool) -- ^ "daemon" - Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness
  , templateDag :: !(Maybe DAGTemplate) -- ^ "dag" - DAG template subtype which runs a DAG
  , templateInputs :: !(Maybe Inputs) -- ^ "inputs" - Inputs describe what inputs parameters and artifacts are supplied to this template
  , templateMetadata :: !(Maybe Metadata) -- ^ "metadata" - Metdata sets the pods&#39;s metadata, i.e. annotations and labels
  , templateName :: !(Text) -- ^ /Required/ "name" - Name is the name of the template
  , templateNodeSelector :: !(Maybe (Map.Map String Text)) -- ^ "nodeSelector" - NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.
  , templateOutputs :: !(Maybe Outputs) -- ^ "outputs" - Outputs describe the parameters and artifacts that this template produces
  , templateParallelism :: !(Maybe Integer) -- ^ "parallelism" - Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.
  , templateResource :: !(Maybe ResourceTemplate) -- ^ "resource" - Resource template subtype which can run k8s resources
  , templateRetryStrategy :: !(Maybe RetryStrategy) -- ^ "retryStrategy" - RetryStrategy describes how to retry a template when it fails
  , templateScript :: !(Maybe ScriptTemplate) -- ^ "script" - Script runs a portion of code against an interpreter
  , templateSidecars :: !(Maybe [Sidecar]) -- ^ "sidecars" - Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes
  , templateSteps :: !(Maybe [[WorkflowStep]]) -- ^ "steps" - Steps define a series of sequential/parallel workflow steps
  , templateSuspend :: !(Maybe SuspendTemplate) -- ^ "suspend" - Suspend template subtype which can suspend a workflow when reaching the step
  , templateTolerations :: !(Maybe [V1Toleration]) -- ^ "tolerations" - Tolerations to apply to workflow pods.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Template
instance A.FromJSON Template where
  parseJSON = A.withObject "Template" $ \o ->
    Template
      <$> (o .:? "activeDeadlineSeconds")
      <*> (o .:? "affinity")
      <*> (o .:? "archiveLocation")
      <*> (o .:? "container")
      <*> (o .:? "daemon")
      <*> (o .:? "dag")
      <*> (o .:? "inputs")
      <*> (o .:? "metadata")
      <*> (o .:  "name")
      <*> (o .:? "nodeSelector")
      <*> (o .:? "outputs")
      <*> (o .:? "parallelism")
      <*> (o .:? "resource")
      <*> (o .:? "retryStrategy")
      <*> (o .:? "script")
      <*> (o .:? "sidecars")
      <*> (o .:? "steps")
      <*> (o .:? "suspend")
      <*> (o .:? "tolerations")

-- | ToJSON Template
instance A.ToJSON Template where
  toJSON Template {..} =
   _omitNulls
      [ "activeDeadlineSeconds" .= templateActiveDeadlineSeconds
      , "affinity" .= templateAffinity
      , "archiveLocation" .= templateArchiveLocation
      , "container" .= templateContainer
      , "daemon" .= templateDaemon
      , "dag" .= templateDag
      , "inputs" .= templateInputs
      , "metadata" .= templateMetadata
      , "name" .= templateName
      , "nodeSelector" .= templateNodeSelector
      , "outputs" .= templateOutputs
      , "parallelism" .= templateParallelism
      , "resource" .= templateResource
      , "retryStrategy" .= templateRetryStrategy
      , "script" .= templateScript
      , "sidecars" .= templateSidecars
      , "steps" .= templateSteps
      , "suspend" .= templateSuspend
      , "tolerations" .= templateTolerations
      ]


-- | Construct a value of type 'Template' (by applying it's required fields, if any)
mkTemplate
  :: Text -- ^ 'templateName': Name is the name of the template
  -> Template
mkTemplate templateName =
  Template
  { templateActiveDeadlineSeconds = Nothing
  , templateAffinity = Nothing
  , templateArchiveLocation = Nothing
  , templateContainer = Nothing
  , templateDaemon = Nothing
  , templateDag = Nothing
  , templateInputs = Nothing
  , templateMetadata = Nothing
  , templateName
  , templateNodeSelector = Nothing
  , templateOutputs = Nothing
  , templateParallelism = Nothing
  , templateResource = Nothing
  , templateRetryStrategy = Nothing
  , templateScript = Nothing
  , templateSidecars = Nothing
  , templateSteps = Nothing
  , templateSuspend = Nothing
  , templateTolerations = Nothing
  }

-- ** ValueFrom
-- | ValueFrom
-- ValueFrom describes a location in which to obtain the value to a parameter
data ValueFrom = ValueFrom
  { valueFromJqFilter :: !(Maybe Text) -- ^ "jqFilter" - JQFilter expression against the resource object in resource templates
  , valueFromJsonPath :: !(Maybe Text) -- ^ "jsonPath" - JSONPath of a resource to retrieve an output parameter value from in resource templates
  , valueFromParameter :: !(Maybe Text) -- ^ "parameter" - Parameter reference to a step or dag task in which to retrieve an output parameter value from (e.g. &#39;{{steps.mystep.outputs.myparam}}&#39;)
  , valueFromPath :: !(Maybe Text) -- ^ "path" - Path in the container to retrieve an output parameter value from in container templates
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValueFrom
instance A.FromJSON ValueFrom where
  parseJSON = A.withObject "ValueFrom" $ \o ->
    ValueFrom
      <$> (o .:? "jqFilter")
      <*> (o .:? "jsonPath")
      <*> (o .:? "parameter")
      <*> (o .:? "path")

-- | ToJSON ValueFrom
instance A.ToJSON ValueFrom where
  toJSON ValueFrom {..} =
   _omitNulls
      [ "jqFilter" .= valueFromJqFilter
      , "jsonPath" .= valueFromJsonPath
      , "parameter" .= valueFromParameter
      , "path" .= valueFromPath
      ]


-- | Construct a value of type 'ValueFrom' (by applying it's required fields, if any)
mkValueFrom
  :: ValueFrom
mkValueFrom =
  ValueFrom
  { valueFromJqFilter = Nothing
  , valueFromJsonPath = Nothing
  , valueFromParameter = Nothing
  , valueFromPath = Nothing
  }

-- ** Workflow
-- | Workflow
-- Workflow is the definition of a workflow resource
data Workflow = Workflow
  { workflowApiVersion :: !(Maybe Text) -- ^ "apiVersion" - APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
  , workflowKind :: !(Maybe Text) -- ^ "kind" - Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
  , workflowMetadata :: !(V1ObjectMeta) -- ^ /Required/ "metadata"
  , workflowSpec :: !(WorkflowSpec) -- ^ /Required/ "spec"
  , workflowStatus :: !(WorkflowStatus) -- ^ /Required/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Workflow
instance A.FromJSON Workflow where
  parseJSON = A.withObject "Workflow" $ \o ->
    Workflow
      <$> (o .:? "apiVersion")
      <*> (o .:? "kind")
      <*> (o .:  "metadata")
      <*> (o .:  "spec")
      <*> (o .:  "status")

-- | ToJSON Workflow
instance A.ToJSON Workflow where
  toJSON Workflow {..} =
   _omitNulls
      [ "apiVersion" .= workflowApiVersion
      , "kind" .= workflowKind
      , "metadata" .= workflowMetadata
      , "spec" .= workflowSpec
      , "status" .= workflowStatus
      ]


-- | Construct a value of type 'Workflow' (by applying it's required fields, if any)
mkWorkflow
  :: V1ObjectMeta -- ^ 'workflowMetadata' 
  -> WorkflowSpec -- ^ 'workflowSpec' 
  -> WorkflowStatus -- ^ 'workflowStatus' 
  -> Workflow
mkWorkflow workflowMetadata workflowSpec workflowStatus =
  Workflow
  { workflowApiVersion = Nothing
  , workflowKind = Nothing
  , workflowMetadata
  , workflowSpec
  , workflowStatus
  }

-- ** WorkflowList
-- | WorkflowList
-- WorkflowList is list of Workflow resources
data WorkflowList = WorkflowList
  { workflowListApiVersion :: !(Maybe Text) -- ^ "apiVersion" - APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
  , workflowListItems :: !([Workflow]) -- ^ /Required/ "items"
  , workflowListKind :: !(Maybe Text) -- ^ "kind" - Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
  , workflowListMetadata :: !(V1ListMeta) -- ^ /Required/ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkflowList
instance A.FromJSON WorkflowList where
  parseJSON = A.withObject "WorkflowList" $ \o ->
    WorkflowList
      <$> (o .:? "apiVersion")
      <*> (o .:  "items")
      <*> (o .:? "kind")
      <*> (o .:  "metadata")

-- | ToJSON WorkflowList
instance A.ToJSON WorkflowList where
  toJSON WorkflowList {..} =
   _omitNulls
      [ "apiVersion" .= workflowListApiVersion
      , "items" .= workflowListItems
      , "kind" .= workflowListKind
      , "metadata" .= workflowListMetadata
      ]


-- | Construct a value of type 'WorkflowList' (by applying it's required fields, if any)
mkWorkflowList
  :: [Workflow] -- ^ 'workflowListItems' 
  -> V1ListMeta -- ^ 'workflowListMetadata' 
  -> WorkflowList
mkWorkflowList workflowListItems workflowListMetadata =
  WorkflowList
  { workflowListApiVersion = Nothing
  , workflowListItems
  , workflowListKind = Nothing
  , workflowListMetadata
  }

-- ** WorkflowSpec
-- | WorkflowSpec
-- WorkflowSpec is the specification of a Workflow.
data WorkflowSpec = WorkflowSpec
  { workflowSpecAffinity :: !(Maybe V1Affinity) -- ^ "affinity" - Affinity sets the scheduling constraints for all pods in the workflow. Can be overridden by an affinity specified in the template
  , workflowSpecArguments :: !(Maybe Arguments) -- ^ "arguments" - Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the &#39;workflow&#39; variable prefix. e.g. {{workflow.parameters.myparam}}
  , workflowSpecEntrypoint :: !(Text) -- ^ /Required/ "entrypoint" - Entrypoint is a template reference to the starting point of the workflow
  , workflowSpecImagePullSecrets :: !(Maybe [V1LocalObjectReference]) -- ^ "imagePullSecrets" - ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  , workflowSpecNodeSelector :: !(Maybe (Map.Map String Text)) -- ^ "nodeSelector" - NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.
  , workflowSpecOnExit :: !(Maybe Text) -- ^ "onExit" - OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary workflow.
  , workflowSpecParallelism :: !(Maybe Integer) -- ^ "parallelism" - Parallelism limits the max total parallel pods that can execute at the same time in a workflow
  , workflowSpecServiceAccountName :: !(Maybe Text) -- ^ "serviceAccountName" - ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
  , workflowSpecSuspend :: !(Maybe Bool) -- ^ "suspend" - Suspend will suspend the workflow and prevent execution of any future steps in the workflow
  , workflowSpecTemplates :: !([Template]) -- ^ /Required/ "templates" - Templates is a list of workflow templates used in a workflow
  , workflowSpecTolerations :: !(Maybe [V1Toleration]) -- ^ "tolerations" - Tolerations to apply to workflow pods.
  , workflowSpecVolumeClaimTemplates :: !(Maybe [V1PersistentVolumeClaim]) -- ^ "volumeClaimTemplates" - VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow
  , workflowSpecVolumes :: !(Maybe [V1Volume]) -- ^ "volumes" - Volumes is a list of volumes that can be mounted by containers in a workflow.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkflowSpec
instance A.FromJSON WorkflowSpec where
  parseJSON = A.withObject "WorkflowSpec" $ \o ->
    WorkflowSpec
      <$> (o .:? "affinity")
      <*> (o .:? "arguments")
      <*> (o .:  "entrypoint")
      <*> (o .:? "imagePullSecrets")
      <*> (o .:? "nodeSelector")
      <*> (o .:? "onExit")
      <*> (o .:? "parallelism")
      <*> (o .:? "serviceAccountName")
      <*> (o .:? "suspend")
      <*> (o .:  "templates")
      <*> (o .:? "tolerations")
      <*> (o .:? "volumeClaimTemplates")
      <*> (o .:? "volumes")

-- | ToJSON WorkflowSpec
instance A.ToJSON WorkflowSpec where
  toJSON WorkflowSpec {..} =
   _omitNulls
      [ "affinity" .= workflowSpecAffinity
      , "arguments" .= workflowSpecArguments
      , "entrypoint" .= workflowSpecEntrypoint
      , "imagePullSecrets" .= workflowSpecImagePullSecrets
      , "nodeSelector" .= workflowSpecNodeSelector
      , "onExit" .= workflowSpecOnExit
      , "parallelism" .= workflowSpecParallelism
      , "serviceAccountName" .= workflowSpecServiceAccountName
      , "suspend" .= workflowSpecSuspend
      , "templates" .= workflowSpecTemplates
      , "tolerations" .= workflowSpecTolerations
      , "volumeClaimTemplates" .= workflowSpecVolumeClaimTemplates
      , "volumes" .= workflowSpecVolumes
      ]


-- | Construct a value of type 'WorkflowSpec' (by applying it's required fields, if any)
mkWorkflowSpec
  :: Text -- ^ 'workflowSpecEntrypoint': Entrypoint is a template reference to the starting point of the workflow
  -> [Template] -- ^ 'workflowSpecTemplates': Templates is a list of workflow templates used in a workflow
  -> WorkflowSpec
mkWorkflowSpec workflowSpecEntrypoint workflowSpecTemplates =
  WorkflowSpec
  { workflowSpecAffinity = Nothing
  , workflowSpecArguments = Nothing
  , workflowSpecEntrypoint
  , workflowSpecImagePullSecrets = Nothing
  , workflowSpecNodeSelector = Nothing
  , workflowSpecOnExit = Nothing
  , workflowSpecParallelism = Nothing
  , workflowSpecServiceAccountName = Nothing
  , workflowSpecSuspend = Nothing
  , workflowSpecTemplates
  , workflowSpecTolerations = Nothing
  , workflowSpecVolumeClaimTemplates = Nothing
  , workflowSpecVolumes = Nothing
  }

-- ** WorkflowStep
-- | WorkflowStep
-- WorkflowStep is a reference to a template to execute in a series of step
data WorkflowStep = WorkflowStep
  { workflowStepArguments :: !(Maybe Arguments) -- ^ "arguments" - Arguments hold arguments to the template
  , workflowStepName :: !(Maybe Text) -- ^ "name" - Name of the step
  , workflowStepTemplate :: !(Maybe Text) -- ^ "template" - Template is a reference to the template to execute as the step
  , workflowStepWhen :: !(Maybe Text) -- ^ "when" - When is an expression in which the step should conditionally execute
  , workflowStepWithItems :: !(Maybe [Item]) -- ^ "withItems" - WithItems expands a step into multiple parallel steps from the items in the list
  , workflowStepWithParam :: !(Maybe Text) -- ^ "withParam" - WithParam expands a step into from the value in the parameter
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkflowStep
instance A.FromJSON WorkflowStep where
  parseJSON = A.withObject "WorkflowStep" $ \o ->
    WorkflowStep
      <$> (o .:? "arguments")
      <*> (o .:? "name")
      <*> (o .:? "template")
      <*> (o .:? "when")
      <*> (o .:? "withItems")
      <*> (o .:? "withParam")

-- | ToJSON WorkflowStep
instance A.ToJSON WorkflowStep where
  toJSON WorkflowStep {..} =
   _omitNulls
      [ "arguments" .= workflowStepArguments
      , "name" .= workflowStepName
      , "template" .= workflowStepTemplate
      , "when" .= workflowStepWhen
      , "withItems" .= workflowStepWithItems
      , "withParam" .= workflowStepWithParam
      ]


-- | Construct a value of type 'WorkflowStep' (by applying it's required fields, if any)
mkWorkflowStep
  :: WorkflowStep
mkWorkflowStep =
  WorkflowStep
  { workflowStepArguments = Nothing
  , workflowStepName = Nothing
  , workflowStepTemplate = Nothing
  , workflowStepWhen = Nothing
  , workflowStepWithItems = Nothing
  , workflowStepWithParam = Nothing
  }




